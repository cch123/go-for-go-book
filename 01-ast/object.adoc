= スコープとオブジェクト

Goはレキシカルスコープを形成するので、ソースコード中の識別子が表す対象（オブジェクト）を文法的な構造によって区別することができます。

例えば次のコードでは3種類の `x` が登場しますが、それぞれ

* `import` したパッケージ名（`import x "..."`）
* 定義された変数（`x := ...`）
* 関数の仮引数名（`func (x ...)`）

と、静的に区別することができます。

.3種類の `x` が出てくるソースコード
[source,go]
----
package p

import x "pkg" // <1>

func f() {
    if x := x.f(); x != nil { // <2>
        x(func(x int) int { return x + 1 }) // <3>
    }
}
----

これらをプログラム的に解析するためのAPIも提供されています。以下ではこれらを見ていきます。

== ast.Object

識別子を表す `ast.Ident` には、`*ast.Object` 型の `Obj` というフィールドが定義されていました。

godoc::go/ast.Ident[]

godoc::go/ast.Object[]

この `ast.Object` が、識別子の表すオブジェクトに対応します（文法的に同じ対象を指す識別子は同じ `ast.Object` を共有します）。

`Kind` は `ObjKind` 型に定義されている値のいずれかを取り、オブジェクトの種類を表します。

godoc::go/ast.Bad[]

パッケージ名、定数名、型名、変数名、関数名またはメソッド名に加え、ラベル名もスコープを持った識別子になります。

`Data` や `Type` フィールドはオブジェクトの詳しい情報を保持しますが、この情報には構文解析の時点では不完全であるものもあり、<<型解析>> によって得られる情報を参照することのほうが多いでしょう。

// TODO もっと詳しく

先ほど例に挙げたコードを解析してみましょう。

goexample::astobject[]

goexample::astobject[output]

// XXX パッケージ名の場合は Obj == nil なのは型解析しないと意味ある情報が出てこないから？ TODO ast.NewPackage してみる

`import` したパッケージ名としての `x`、定義された変数としての `x`、関数の仮引数名としての `x` がそれぞれ違った `Obj` をもち、文法的に同じものであれば `Obj` が同じものを指しています。

// TODO: ast.Object だけでは不完全な件

== スコープ

Go のスコープはブロックにもとづいて作られます。ブレース（`{...}`）による明示的なブロックの他に作られるブロックもあります。link:https://golang.org/ref/spec#Declarations_and_scope[Declarations and scope - The Go Programming Language Specification] に述べられていますが、抄訳します:

* あらかじめ定義されている識別子（`nil` など）の属するユニバースブロック（universe block）に属します。
* トップレベルの定数、変数、関数（メソッドは除く）はパッケージブロック（package block）に属します。
* インポートされたパッケージの名前は、それを含むファイルブロック（file block）に属します。

== ast.Scope

WARNING: TODO: File.Scope とか
