= スコープとオブジェクト

// TODO: 名前？ 識別子？

Goのソースコードにおいて名前はレキシカルスコープを持ち、その有効範囲は静的に決まります。構文解析のAPIにもスコープに関係するものがいくつか存在します。以下ではこれらについて簡単に見ていきます。

== 構文解析だけでは不十分な例

ただし、構文解析だけでは全ての名前を正しく解決できるわけではありません。

以下のプログラムには `T{k: 0}` という同じ形をしたコードが出現します。ここで `k` が指すものは一方ではトップレベルの定数、もう一方では構造体のフィールドと、それぞれ違ったものになります（link:https://github.com/golang/example/tree/master/gotypes[`go/types`: The Go Type Checker] より）。

goexample::indeterminableident[]

また、名前なしの `import` 文によって導入されたパッケージ名は構文解析だけでは判定できません。

[source,go]
----
import "github.com/motemen/go-gitconfig" // gitconfig という名前が導入される
----

これらも含めて正しく（Go言語の仕様通りに）名前のスコープを決定するには、意味解析の手続きを経なくてはなりません。

WARNING: このように、`go/ast` のAPIで得られるスコープの情報は不完全なもので、あくまでソースコードが構文的に誤りのないことを保証するものです。より正確で詳しい情報が知りたい場合には<<型解析>>を行います。

== スコープ

Goのスコープはブロックにもとづいて作られます。ブレース（`{ ... }`）による明示的なブロックのほかにも、構文から作られるスコープがあります。link:https://golang.org/ref/spec#Declarations_and_scope[Declarations and scope - The Go Programming Language Specification] に述べられていますが、抄訳します：

* あらかじめ定義されている名前（`nil` や `int` など）はユニバースブロック（universe block）に属します。
* トップレベルの定数、変数、関数（メソッドを除く）はパッケージブロック（package block）に属します。
* インポートされたパッケージの名前は、それを含むファイルブロック（file block）に属します。

`go/ast` のAPIを使用してアクセスできるのは、ファイルブロックのスコープとパッケージブロックのスコープ（<<パッケージ>>）のみです。

構文解析によって得られたスコープは `ast.Scope` として表現されます：

godoc::go/ast.Scope[]

スコープはその外側のスコープへの参照と、名前から<<オブジェクト>>へのマッピングで構成されています。あるスコープはその内側のスコープの情報を保持していませんが、これはスコープが基本的に識別子の解決のために使われるものだからです。あるスコープに出現した識別子がどんなオブジェクトであるかを判定するには、子スコープの情報は不要であり、親スコープを辿ることによって解決されます。

== オブジェクト

ソースコード中の識別子を表す `ast.Ident` には、`*ast.Object` 型の `Obj` というフィールドが定義されていました。

godoc::go/ast.Ident[]

`go/ast` や `go/types` では、term:名前をつけられた言語上の要素[named language entity]をterm:オブジェクト[object]と呼んでおり、構文上のオブジェクトはこの `ast.Object` によって表されています。

// TODO: named language entity の訳語

`ast.Object` の `Decl` フィールドは、そのオブジェクトが宣言されたノードを表します。

godoc::go/ast.Object[]

構文上同じオブジェクトを指すと思わしき識別子に対応する `*ast.Ident` は、同じ `ast.Object` を共有します。

// TODO ソースは？

// gofind go/ast.Object.Type $(go list std)

goexample::astobject[]

goexample::astobject[output]

`import` したパッケージ名としての `x`、定義された変数としての `x`、関数の仮引数名としての `x` がそれぞれ違った `Obj` をもち、文法的に同じものであれば `Obj` が同じものを指しています。

`Kind` フィールドは `ObjKind` 型に定義されている値のいずれかを取り、オブジェクトの種類を表します。

godoc::go/ast.Bad[]

パッケージ名、定数名、型名、変数名、関数名またはメソッド名に加え、ラベル名もオブジェクトとして扱われることがわかります。

[NOTE]
====
`Object` には、`Data` や `Type` など、さらに詳しい情報を保持するために用意されているフィールドも存在します。しかし、先に述べたように構文解析だけでは完全な情報が得られないので、これらの詳しい情報が必要な場合には<<型解析>>のAPIを使用することになるでしょう。

ちなみに、現在 `Type` フィールドはどこからも利用されていないようです。
====

== パッケージ

Goでは、ひとつのディレクトリに配置された複数のソースファイルが集まって、ひとつのパッケージを構成します。パッケージを構成するソースコードに登場する名前は、すべてどこかで定義されている必要があるという意味において、解決できなければいけません。

=== ast.File.Scopeとast.File.Unresolved

godoc::go/ast.File[]

`ast.File` 構造体の `Scope` フィールドは、当該のソースファイルのファイルスコープ（ファイルブロック）を表します。ここで解決できなかったものは `Unresolved` フィールドに記録されます。正しくコンパイルできるソースコードであれば、ここに入るのは

* `import` によってファイルスコープに導入される名前
* 同パッケージの他ファイルのトップレベルに定義されている名前
* ユニバースブロックに定義されている名前

への参照になるはずです。

// gofind go/ast.File.Unresolved $(go list go/...)
// gofind go/parser.parser.unresolved go/parser
// go/parser.parser.tryResolve() 内で収集され、
// parseFile() の最後にパッケージスコープでもって解決してる

=== ast.Package

godoc::go/ast.Package[]

複数のソースファイルをまとめ、パッケージとして扱うものが `ast.Package` です。`Scope` はパッケージスコープを表し、各々のファイルのトップレベルに宣言された名前を格納します。`Imports` は `import` 宣言によって導入された名前を保持します。

`ast.Package` は `ast.NewPackage` で生成されます。

godoc::go/ast.NewPackage[]

第3引数の `importer ast.Importer` は、`import` されるパッケージパスから、それが導入するオブジェクトを（記録しつつ）返す関数を渡します。

godoc::go/ast.Importer[]

`go` 本体と同じ挙動をするという意味での `ast.Importer` のカノニカルな実装は提供されていません。パッケージファイルのインポートを解決するために、ビルド済みのオブジェクトファイルを読み込むAPIは提供されています（TODO: 後述）。これは型も含めたパッケージ情報の読み込みとなるため、文法レベルの情報を扱う `ast` パッケージの範疇を外れます。

第4引数の `universe *ast.Scope` には、パッケージの外側のスコープであるユニバーススコープを渡します。こちらについても、型におけるユニバーススコープの情報を得るAPIは存在しますが、抽象構文木のみのレベルのものはありません。

これらを正しく渡すことで完全な `ast.Package` を生成することができますが、正しい情報が必要な場合には<<型解析>>を行うことを考えたほうがよいでしょう。

WARNING: TODO: golang/gddo の例

== parser.ParseDir

Goでは、ひとつのパッケージに属するソースコードファイルは同じディレクトリ直下に配置されます。これらを一度に構文解析し、`ast.Package` を生成するAPIもあります。

godoc::go/parser.ParseDir[]

この関数では `ast.NewPackage` で行われるような名前の解決は行われません。

NOTE: `ParseDir` はひとつのディレクトリからひとつでなく複数のパッケージを返しうるAPIになっていますが、異常なことではありません。普通にコンパイルできるような構成においても、複数のパッケージがひとつのディレクトリに共在することはありえます（link:https://golang.org/cmd/go/#hdr-Test_packages[Test packages]）。

////////////////////////////////////////

== 構文解析で分からないこと

// TODO: 識別子の解決とは？

ただし、構文解析だけでは全ての識別子を解決できるわけではありません。例えば以下のプログラムには `T{k: "foo"}` という同じ形をしたコードが出現しますが、ここで `k` が指すものは一方ではトップレベルの定数、もう一方では構造体のフィールドと、それぞれ違ったものです。

goexample::indeterminableident[]

また、名前なしの `import` 文によって導入されたパッケージ名は構文解析だけでは判定できません。

[source,go]
----
import "github.com/motemen/go-gitconfig" // gitconfig という名前が導入される
----

これらは
WARNING: スコープや識別子の実体について正確に知りたい場合は、意味解析の手続きが必要になります。以下で説明する `ast` パッケージのAPIは、あくまで構文的な正しさを保証するためのもので、目的によっては不完全なものとなり得ます。

== ast.Object

識別子を表す `ast.Ident` には、`*ast.Object` 型の `Obj` というフィールドが定義されていました。

godoc::go/ast.Ident[]

godoc::go/ast.Object[]

この `ast.Object` が、名前付けられた言語的な要素に対応します。文法的に同じ対象を指す識別子は同じ `ast.Object` を共有します。

// TODO: named entity の訳語

`Kind` フィールドは `ObjKind` 型に定義されている値のいずれかを取り、オブジェクトの種類を表します。

godoc::go/ast.Bad[]

パッケージ名、定数名、型名、変数名、関数名またはメソッド名に加え、ラベル名もオブジェクトとして扱われることがわかります。

`ast.Object` の `Decl` フィールドはその名前がどこで宣言されたかを表します。

`Data` や `Type` オブジェクトの詳しい情報を保持しますが、この情報には構文解析の時点では不完全であるものもあり、<<型解析>> によって得られる情報を参照することのほうが多いでしょう。

// Type フィールドが使われることはある？
// gofind go/ast.Object.Type $(go list std)

先ほど例に挙げたコードを解析してみましょう。

goexample::astobject[]

goexample::astobject[output]

// XXX パッケージ名の場合は Obj == nil なのは型解析しないと意味ある情報が出てこないから？ TODO ast.NewPackage してみる
// → ast.NewPackage で解決される

`import` したパッケージ名としての `x`、定義された変数としての `x`、関数の仮引数名としての `x` がそれぞれ違った `Obj` をもち、文法的に同じものであれば `Obj` が同じものを指しています。

// TODO: ast.Object だけでは不完全な件

== スコープ

Go のスコープはブロックにもとづいて作られます。ブレース（`{...}`）による明示的なブロックの他に作られるブロックもあります。link:https://golang.org/ref/spec#Declarations_and_scope[Declarations and scope - The Go Programming Language Specification] に述べられていますが、抄訳します:

* あらかじめ定義されている識別子（`nil` など）の属するユニバースブロック（universe block）に属します。
* トップレベルの定数、変数、関数（メソッドは除く）はパッケージブロック（package block）に属します。
* インポートされたパッケージの名前は、それを含むファイルブロック（file block）に属します。

`go/ast` のAPIにより得られるのはファイルブロックのスコープとパッケージブロックのスコープ（<<パッケージ>>）のみです。関数の本体ブロックなど、それより細かいスコープを扱いたいときは `go/types` （<<型解析>>）を使用します。またユニバースブロックも構文解析の段階では得られません。

== ast.Scope、ast.File.Scope、ast.File.Unresolved

`ast.Scope` はスコープ内の名前からオブジェクトへのマッピングを保持しています。

godoc::go/ast.Scope[]

`ast.File` の `Scope` フィールドは `*ast.Scope` 型でした。

godoc::go/ast.File[]

`Scope` フィールドはこのファイルだけから構成したパッケージスコープに対応します。これより内側のスコープに対応する `ast.Scope` は `go/ast` の内部で出現するのみで、APIの結果からアクセスすることはできません（たぶん）。パッケージスコープをより完全に近づけるためには、<<ast.NewPackage>> を呼びます（それでも完全にはなりませんが）。

// TODO: ファイルスコープでないのはなんで？ トップレベル変数があるから？

また `Unresolved` フィールドはファイルの構文解析中、オブジェクトに解決できなかった識別子のリストになっています。正しくコンパイルできるソースコードであれば以下のようなものになるはずです:

* 定義済みの名前。
* 同じパッケージの他のファイルに定義されているトップレベルの名前。
* `import` されたパッケージの名前。

// TODO: 他にはない？

////////////////////////////////////////
