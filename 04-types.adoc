= 型解析

ここまで見てきたようなGoの抽象構文木を扱うAPIを知っていれば、Goプログラムを対象にしてできることの7割ほどは実現できたも同然です。しかし、

* ソースコード中に登場する名前が定義された位置や、
* ある型がインタフェースを実装しているか

など、プログラムの構造を越えたより高度な情報が必要になった場合は、**型解析**に手を出す必要があります。

この章では、Goパッケージの型チェックと型にまつわるデータ構造を提供する `go/types` パッケージのAPIを見ていきます。

- 名前解決
- 定数畳み込み
- 型推論

== 型チェックを行う

`types` パッケージによる型チェックは、`types.Config` 構造体の `Check` メソッドを呼ぶところから始まります。

godoc::go/types.Config.Check[]

`files []ast.File` には、ひとつのパッケージを構成する構文解析されたファイル群を指定します。<<ファイルの構文解析>> で `files` の要素を生成した際に使用した `fset` も引数として渡します。

最後の引数である `info *types.Info` は、パッケージ内の型にまつわる詳細な情報を格納する先として指定します。単純に型チェックを行いたいだけの場合は `nil` でも構いません。

goexample::typechecksimple[]

goexample::typechecksimple[output]

パッケージのトップレベルに定義された `s` という変数の型が `string` であるという情報が得られました。

このように、型チェックおよび型情報の取得は `Config` 構造体をエントリポイントとしてパッケージごとに行います。結果は <<types.Package>> 構造体と、ここでは登場しませんでしたが <<types.Info>> 構造体に格納されます。

== パッケージのインポート

先ほどの例では `Config.Importer` を設定していました。これは `types.Importer` という型を持つフィールドです。

godoc::go/types.Importer[]

`types.Importer` は、パッケージのパスを解決し、そのパッケージに関する型レベルの情報を返すインタフェースです。具体的には、コンパイルされたパッケージオブジェクトを `GOPATH` から探し出し、解析するのが仕事です。

この具体的な実装を提供するのが `go/importer` パッケージです。`importer.Default()` は実行中のバイナリのコンパイラ（`runtime.Compiler`）に対応するインポートの実装を返します。

godoc::go/importer.Default[]

以下はパッケージを読み込み、そのパッケージが公開している名前および依存しているパッケージの情報を印字する例です。

goexample::importer[]

goexample::importer[output]

プログラムの型チェックにはインポートしているパッケージがどんな名前と型を提供するのか知る必要があるため、`Config` 構造体の `Importer` フィールドという形でその実装を指定します。

== types.Config

== 型チェックのエラー

== パッケージの型情報

=== types.Package

=== types.Info

== スコープ

== 型とオブジェクト

=== types.Type

=== types.Object

[appendix]
== types.Typeの階層

----
include::listings/types-type-hierarchy.txt[]
----

[appendix]
== types.Objectの階層

----
include::listings/types-object-hierarchy.txt[]
----
