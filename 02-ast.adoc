= 構文解析

そのままではただの文字列であるだけのGoのソースコードをプログラムにとって意味のある操作可能な対象とするには、まずソースコードを構文解析して抽象構文木に変換する必要があります。いったん抽象構文木を手元に得てしまえば、任意のソースコードをプログラムから扱うのはとても簡単です。ここでは、

* Goのソースコードの抽象構文木がどのようにして得られるのか、
* 構文要素がどのように表現されているのか

といったことについて見ていきます。

== 抽象構文木

Goのソースコードの構文解析を行うには、標準パッケージの `go/parser` を使用します。
まずはGoの式（expression）を解析するところからはじめましょう。

goexample::parseexpr[]

NOTE: 簡単のため、サンプルコードではエラーを無視することがあります。

`go/parser.ParserExpr` はGoの式である文字列を構文解析し、式を表現する抽象構文木である `ast.Expr` を返します。

godoc::go/parser.ParseExpr[]

実行すると以下のように、式 `a * -1` に対応する抽象構文木が `*ast.BinaryExpr` として得られたことが分かります。

goexample::parseexpr[output]

二項演算子 `*` の左の項である `a` が `X`（`*ast.Ident`）として、右の項である `-1` が `Y`（`*ast.UnaryExpr`）として表現されていそうだ、ということが見て取れます。

ただ、`%#v` による表示では定数値の意味やポインタの指す先までを知ることはできません。構文木をさらに深く見ていくには、`ast.Print` 関数が便利です:

goexample::parseexpr-print[]
goexample::parseexpr-print[output]

`X.Name` が `"a"` であることや `Op` が `"*"` であることなど、先ほどの式 `a * -1` を表す抽象構文木の構造がより詳細に理解できます。

`ast.Print` は抽象構文木を人間に読みやすい形で標準出力に印字します。便利な関数ですがあくまで開発中やデバッグに便利な関数であって、実際にコードを書いて何かを達成するために直接これを使うことはないでしょう。

godoc::go/ast.Print[]

コード中で `nil` を渡している第一引数 `fset *token.FileSet` に関しては、あとの節 <<ソースコード中の位置>> で触れます。

== ファイルの構文解析

実践においてGoのソースコードは、ファイル単位で与えられることがほとんどです。ファイルの構文解析を行うには `parser.ParseFile` を使用します。

goexample::parsefile[]
goexample::parsefile[output]

ファイルは `ast.File` 構造体で表現され、トップレベルの宣言などの情報を保持しています。

godoc::go/ast.File[]

== ast.Decl

Declaration xxx は ast.Decl インターフェースで表されます。宣言と呼ばれるものには以下の4種類があります:

* インポート
* トップレベルの関数宣言
* トップレベルの型宣言
* トップレベルの値の宣言

ast.Decl を実装するのは *ast.GenDecl と *ast.FuncDecl のただ2つだけです。上に挙げたうち、関数宣言以外の3種類はすべて GenDecl として表現されます。これら3つは、以下のようにグループ化できるという特徴がありますね:

xxx



== ソースコード中の位置

前の例では `token.FileSet` という新しい構造体が登場しました。これはソースコード上の位置情報を一元化して保持するものです。

さて、`ast.Node` は以下の2メソッドだけからなるインターフェースでした。

godoc::go/ast.Node[]

これらはその名が示すとおり、当該のノードがソースコード上に占める位置をあらわしています。ノードが保持する位置情報である `token.Pos` は単なる整数値であり、これだけではファイル名や行番号など、多くの場合に必要となる情報を得ることはできません。

godoc::go/token.Pos[]

`token.Pos` は `token.FileSet` と組み合わせることで、その完全な情報である `token.Position` に変換できます。

godoc::go/token.FileSet.Position[]

`token.Pos` は特定の `token.FileSet` に対する相対位置としてエンコードされているので、
抽象構文木を生成した際に使用した `token.FileSet` をその後も使い回すことになります。

通常、ひとつのプログラムにただひとつの `token.FileSet` を保持しておけば十分です。

== 構文木の探索

TBD

- ast.Inspect
- ast.Walk

== ast.Node の階層

TBD

== スコープ

TBD

- ast.Scope

== パッケージ

TBD

- ast.NewPackage
- parser.ParseDir

== オブジェクト

TBD

- ast.Object

== コメントとドキュメント

TBD

- parser.ParseComments
- doc.New

== 文字列化

TBD

- go/printer
- go/format

// vim: set ft=asciidoc:
