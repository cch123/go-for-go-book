<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.6.2">
<meta name="author" content="motemen (https://motemen.github.io/)">
<title>GoのためのGo</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css">
<link rel="stylesheet" href="./pygments-default.css">
<style>
body { word-break: break-word; }
</style>

<script>
if (/\.github\.io$/.test(location.host) && location.protocol === 'http:') {
  location.protocol = 'https:';
}
</script>

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
if (!/\blocalhost\b/.test(location.host)) {
  ga('create', 'UA-34276254-7', 'auto');
  ga('send', 'pageview');
}
</script>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>GoのためのGo</h1>
<div class="details">
<span id="author" class="author">motemen (https://motemen.github.io/)</span><br>
<span id="revnumber">version bc91bf0,</span>
<span id="revdate">2018-08-01T19:18:31+09:00</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">目次</div>
<ul class="sectlevel1">
<li><a href="#はじめに">はじめに</a>
<ul class="sectlevel2">
<li><a href="#この本について">この本について</a></li>
<li><a href="#なぜ_goのためのgo_なのか">なぜ「GoのためのGo」なのか</a></li>
<li><a href="#対象バージョン">対象バージョン</a></li>
</ul>
</li>
<li><a href="#構文解析">1. 構文解析</a>
<ul class="sectlevel2">
<li><a href="#式の構文解析">1.1. 式の構文解析</a>
<ul class="sectlevel3">
<li><a href="#ast_print">1.1.1. ast.Print</a></li>
<li><a href="#構文ノードのインタフェース">1.1.2. 構文ノードのインタフェース</a></li>
</ul>
</li>
<li><a href="#ファイルの構文解析">1.2. ファイルの構文解析</a>
<ul class="sectlevel3">
<li><a href="#ファイルの構造">1.2.1. ファイルの構造</a></li>
<li><a href="#parser_parsefile">1.2.2. parser.ParseFile</a></li>
<li><a href="#ast_file">1.2.3. ast.File</a></li>
<li><a href="#構文木の探索">1.2.4. 構文木の探索</a></li>
</ul>
</li>
<li><a href="#構文ノードの実装">1.3. 構文ノードの実装</a>
<ul class="sectlevel3">
<li><a href="#ast_node">1.3.1. ast.Node</a></li>
<li><a href="#ast_decl">1.3.2. ast.Decl</a></li>
<li><a href="#ast_stmt">1.3.3. ast.Stmt</a></li>
<li><a href="#ast_expr">1.3.4. ast.Expr</a></li>
<li><a href="#その他のノード">1.3.5. その他のノード</a></li>
<li><a href="#ast_nodeの階層">Appendix A: ast.Nodeの階層</a></li>
</ul>
</li>
<li><a href="#ソースコード中の位置">1.4. ソースコード中の位置</a>
<ul class="sectlevel3">
<li><a href="#token_pos">1.4.1. token.Pos</a></li>
<li><a href="#token_fileset">1.4.2. token.FileSet</a></li>
<li><a href="#token_position">1.4.3. token.Position</a></li>
</ul>
</li>
<li><a href="#スコープとオブジェクト">1.5. スコープとオブジェクト</a>
<ul class="sectlevel3">
<li><a href="#構文解析だけでは不十分な例">1.5.1. 構文解析だけでは不十分な例</a></li>
<li><a href="#スコープ">1.5.2. スコープ</a></li>
<li><a href="#オブジェクト">1.5.3. オブジェクト</a></li>
<li><a href="#パッケージ">1.5.4. パッケージ</a></li>
<li><a href="#parser_parsedir">1.5.5. parser.ParseDir</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#コメントとドキュメント">2. コメントとドキュメント</a>
<ul class="sectlevel2">
<li><a href="#コメントの解析">2.1. コメントの解析</a></li>
<li><a href="#goにおけるドキュメント">2.2. Goにおけるドキュメント</a></li>
<li><a href="#doc_package">2.3. doc.Package</a>
<ul class="sectlevel3">
<li><a href="#doc_packageのレイアウト">2.3.1. doc.Packageのレイアウト</a></li>
</ul>
</li>
<li><a href="#例示のためのテスト">2.4. 例示のためのテスト</a></li>
</ul>
</li>
<li><a href="#ソースコードの文字列化">3. ソースコードの文字列化</a></li>
<li><a href="#型解析">4. 型解析</a>
<ul class="sectlevel2">
<li><a href="#型チェックを行う">4.1. 型チェックを行う</a></li>
<li><a href="#パッケージのインポート">4.2. パッケージのインポート</a></li>
<li><a href="#types_config">4.3. types.Config</a></li>
<li><a href="#型チェックのエラー">4.4. 型チェックのエラー</a></li>
<li><a href="#パッケージの型情報">4.5. パッケージの型情報</a>
<ul class="sectlevel3">
<li><a href="#types_package">4.5.1. types.Package</a></li>
</ul>
</li>
<li><a href="#typesにおけるスコープ">4.6. typesにおけるスコープ</a>
<ul class="sectlevel3">
<li><a href="#ユニバーススコープ">4.6.1. ユニバーススコープ</a></li>
</ul>
</li>
<li><a href="#typesにおけるオブジェクト">4.7. typesにおけるオブジェクト</a>
<ul class="sectlevel3">
<li><a href="#types_builtin">4.7.1. types.Builtin</a></li>
<li><a href="#types_const">4.7.2. types.Const</a></li>
<li><a href="#types_func">4.7.3. types.Func</a></li>
<li><a href="#types_pkgname">4.7.4. types.PkgName</a></li>
<li><a href="#types_typename">4.7.5. types.TypeName</a></li>
<li><a href="#types_var">4.7.6. types.Var</a></li>
</ul>
</li>
<li><a href="#types_info">4.8. types.Info</a></li>
<li><a href="#型の情報">4.9. 型の情報</a>
<ul class="sectlevel3">
<li><a href="#types_type">4.9.1. types.Type</a></li>
</ul>
</li>
<li><a href="#types_objectの階層">Appendix B: types.Objectの階層</a></li>
<li><a href="#types_typeの階層">Appendix C: types.Typeの階層</a></li>
</ul>
</li>
<li><a href="#ビルド情報">5. ビルド情報</a></li>
<li><a href="#高レベルのapi">6. 高レベルのAPI</a></li>
<li><a href="#ソースコードを読む">7. ソースコードを読む</a>
<ul class="sectlevel2">
<li><a href="#go_doc">7.1. go doc</a>
<ul class="sectlevel3">
<li><a href="#引数の解決_code_parseargs_code">7.1.1. 引数の解決（<code>parseArgs</code>）</a></li>
<li><a href="#ソースコードの解析_code_parsepackage_code">7.1.2. ソースコードの解析（<code>parsePackage</code>）</a></li>
<li><a href="#ドキュメントの表示_code_pacakge_packagedoc_code_など">7.1.3. ドキュメントの表示（<code>Pacakge.packageDoc</code> など）</a></li>
</ul>
</li>
<li><a href="#gofmt">7.2. gofmt</a>
<ul class="sectlevel3">
<li><a href="#gofmtの主なインタフェース">7.2.1. gofmtの主なインタフェース</a></li>
<li><a href="#ソースコードの印字">7.2.2. ソースコードの印字</a></li>
<li><a href="#code_gofmt_s_code_ソースをシンプルにする">7.2.3. <code>gofmt -s</code>: ソースをシンプルにする</a></li>
<li><a href="#code_gofmt_r_code_ソースを書き換える">7.2.4. <code>gofmt -r</code>: ソースを書き換える</a></li>
</ul>
</li>
<li><a href="#stringer">7.3. stringer</a>
<ul class="sectlevel3">
<li><a href="#処理の流れ">7.3.1. 処理の流れ</a></li>
<li><a href="#ソースのロード">7.3.2. ソースのロード</a></li>
<li><a href="#型の発見_code_generator_generate_code">7.3.3. 型の発見（<code>Generator.generate()</code>）</a></li>
<li><a href="#文字列化処理の生成">7.3.4. 文字列化処理の生成</a></li>
</ul>
</li>
<li><a href="#goimports">7.4. goimports</a>
<ul class="sectlevel3">
<li><a href="#code_import_code_の解決">7.4.1. <code>import</code> の解決</a></li>
</ul>
</li>
<li><a href="#guru">7.5. guru</a></li>
<li><a href="#gddo">7.6. gddo</a>
<ul class="sectlevel3">
<li><a href="#外部サービスへの対応">7.6.1. 外部サービスへの対応</a></li>
<li><a href="#仮想的なソースコードディレクトリからドキュメントを生成する">7.6.2. 仮想的なソースコードディレクトリからドキュメントを生成する</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#フロー解析">8. フロー解析</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="はじめに"><a class="anchor" href="#はじめに"></a>はじめに</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="この本について"><a class="anchor" href="#この本について"></a>この本について</h3>
<div class="paragraph">
<p>この本では、Go言語の標準パッケージのうち <code>go/</code> で始まるものについて、実例を交えながら紹介します。ドキュメントとソースコードの中間となることを目指し、実例を交えつつ、ドキュメントだけからはただちに知ることのできないAPI同士の関連や全体としての使い方に焦点を当てます。</p>
</div>
</div>
<div class="sect2">
<h3 id="なぜ_goのためのgo_なのか"><a class="anchor" href="#なぜ_goのためのgo_なのか"></a>なぜ「GoのためのGo」なのか</h3>
<div class="paragraph">
<p>Go言語はシンプルさを念頭にデザインされた言語です。仕様は単純明瞭さのために小さく収められていますが、そのため表現力に欠けているとか、コードが冗長になるという印象を持つ人も多いでしょう。有名なところでは、ジェネリクスや例外といった機能が（今のところ）存在しないことが問題にされることが多いようです。</p>
</div>
<div class="paragraph">
<p>一般に、ソフトウェアエンジニアリングというものは書かれる言語だけに依るものではありません。視点を拡げてGoを取りまくツール群を含めて見てみると、<a href="https://godoc.org/cmd/go#hdr-Run_gofmt_on_package_sources"><code>go fmt</code></a> や <a href="https://godoc.org/golang.org/x/tools/cmd/goimports"><code>goimports</code></a> といったツールが広く使われていること、また <a href="https://blog.golang.org/generate"><code>go generate</code></a> コマンドの存在などを見ても、Goという言語には、人間のプログラミングを機械によってさまざまな面から補助しようという態度があります。</p>
</div>
<div class="paragraph">
<p><code>go/*</code> 標準パッケージは、Goのプログラムを対象とし、解析や操作を行うためのAPIを提供します。これらのAPIを利用し、一種のメタプログラミングを行うことで、Goプログラミングの力をより引き出せるようになるはずです。</p>
</div>
</div>
<div class="sect2">
<h3 id="対象バージョン"><a class="anchor" href="#対象バージョン"></a>対象バージョン</h3>
<div class="paragraph">
<p>この本の内容は、Goバージョン1.7.4に基いています。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="構文解析"><a class="anchor" href="#構文解析"></a>1. 構文解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Goに限らず、プログラムのソースコードは、与えられた状態ではただの文字列でしかありません。</p>
</div>
<div class="paragraph">
<p>ソースコードをプログラムにとって意味のある操作可能な対象とするには、まずソースを構文解析して抽象構文木（<dfn>Abstract Syntax Tree; AST</dfn>）に変換し、Goのデータ構造として表現する必要があります。</p>
</div>
<div class="paragraph">
<p>いったん抽象構文木を手元に得てしまえば、任意のソースコードをプログラムから扱うのはとても簡単です。</p>
</div>
<div class="paragraph">
<p>以下では、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Goのソースコードの抽象構文木がどのようにして得られるのか、</p>
</li>
<li>
<p>抽象構文木において、それぞれの構文要素がどのように表現されているのか</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>といったことを見ていきます。</p>
</div>
<div class="sect2">
<h3 id="式の構文解析"><a class="anchor" href="#式の構文解析"></a>1.1. 式の構文解析</h3>
<div class="paragraph">
<p>Goのソースコードの構文解析を行うには、標準パッケージの <code>go/parser</code> を使用します。
まずはGoの式（<dfn>expression</dfn>）を解析するところからはじめましょう。</p>
</div>
<div class="listingblock">
<div class="title">リスト 1. parseexpr.go <span class="icon"><a class="image" href="https://play.golang.org/p/XPslK7vU3x" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">expr</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseExpr</span><span class="tok-p">(</span><span class="tok-s">&quot;a * -1&quot;</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%#v&quot;</span><span class="tok-p">,</span> <span class="tok-nx">expr</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
簡単のため、サンプルコードではエラーを無視することがあります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>go/parser.ParserExpr</code> はGoの式である文字列を構文解析し、式を表現する抽象構文木である <code>ast.Expr</code> を返します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/parser#ParseExpr">go/parser.ParseExpr</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">ParseExpr</span><span class="tok-p">(</span><span class="tok-nx">x</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Expr</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>実行すると以下のように、式 <code>a * -1</code> に対応する抽象構文木が <code>*ast.BinaryExpr</code> として得られたことが分かります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre>&amp;ast.BinaryExpr{X:(*ast.Ident)(0xc42000ede0), OpPos:3, Op:14, Y:(*ast.UnaryExpr)(0xc42000ee20)}</pre>
</div>
</div>
<div class="paragraph">
<p>二項演算子 <code>*</code> の左の項である <code>a</code> が <code>X</code>（<code>*ast.Ident</code>）として、右の項である <code>-1</code> が <code>Y</code>（<code>*ast.UnaryExpr</code>）として表現されていそうだ、ということが見て取れると思います。</p>
</div>
<div class="sect3">
<h4 id="ast_print"><a class="anchor" href="#ast_print"></a>1.1.1. ast.Print</h4>
<div class="paragraph">
<p><code>%#v</code> による表示でも大まかには構文木のノードの様子を知ることができますが、定数値の意味やさらに深いノードの情報には欠けています。構文木をさらに詳細に見ていくには、<code>ast.Print</code> 関数が便利です：</p>
</div>
<div class="listingblock">
<div class="title">リスト 2. parseexpr-print.go <span class="icon"><a class="image" href="https://play.golang.org/p/uw-z_FnNxc" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">expr</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseExpr</span><span class="tok-p">(</span><span class="tok-s">&quot;a * -1&quot;</span><span class="tok-p">)</span>
    <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Print</span><span class="tok-p">(</span><span class="tok-kc">nil</span><span class="tok-p">,</span> <span class="tok-nx">expr</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>     0  *ast.BinaryExpr {
     1  .  X: *ast.Ident {
     2  .  .  NamePos: 1
     3  .  .  Name: "a"
     4  .  .  Obj: *ast.Object {
     5  .  .  .  Kind: bad
     6  .  .  .  Name: ""
     7  .  .  }
     8  .  }
     9  .  OpPos: 3
    10  .  Op: *
    11  .  Y: *ast.UnaryExpr {
    12  .  .  OpPos: 5
    13  .  .  Op: -
    14  .  .  X: *ast.BasicLit {
    15  .  .  .  ValuePos: 6
    16  .  .  .  Kind: INT
    17  .  .  .  Value: "1"
    18  .  .  }
    19  .  }
    20  }</pre>
</div>
</div>
<div class="paragraph">
<p><code>X.Name</code> が <code>"a"</code> であることや <code>Op</code> が <code>*</code> であることなど、先ほどの式 <code>a * -1</code> を表す抽象構文木の構造がより詳細に掴めます。</p>
</div>
<div class="paragraph">
<p><code>ast.Print</code> は抽象構文木を人間に読みやすい形で標準出力に印字します。便利な関数ですがあくまで開発中やデバッグ用途であって、実際にコードを書いて何かを達成するために直接これを使うことはないでしょう。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Print">go/ast.Print</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">Print</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">x</span> <span class="tok-kd">interface</span><span class="tok-p">{})</span> <span class="tok-kt">error</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一引数 <code>fset</code> に関しては、<a href="#ソースコード中の位置">ソースコード中の位置</a> で触れます。ここでは <code>nil</code> を渡せば十分です。</p>
</div>
</div>
<div class="sect3">
<h4 id="構文ノードのインタフェース"><a class="anchor" href="#構文ノードのインタフェース"></a>1.1.2. 構文ノードのインタフェース</h4>
<div class="paragraph">
<p><code>ast.ParseExpr</code> の返り値となっている <code>ast.Expr</code> はインタフェース型であり、先ほどの例で得られたのは具体的には <code>*ast.BinaryExpr</code> 構造体でした。これは二項演算に対応する構文ノードです。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#BinaryExpr">go/ast.BinaryExpr</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">BinaryExpr</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">X</span>     <span class="tok-nx">Expr</span>        <span class="tok-c1">// left operand</span>
    <span class="tok-nx">OpPos</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>   <span class="tok-c1">// position of Op</span>
    <span class="tok-nx">Op</span>    <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Token</span> <span class="tok-c1">// operator</span>
    <span class="tok-nx">Y</span>     <span class="tok-nx">Expr</span>        <span class="tok-c1">// right operand</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>二項演算の左右の式である <code>X</code> や <code>Y</code> も <code>ast.Expr</code> として定義されていることがわかります。先ほどの例では <code>*ast.Ident</code> や <code>*ast.UnaryExpr</code> がその具体的な値となっていました。</p>
</div>
<div class="paragraph">
<p>これらの構造体を含め、すべてのGoの式に対応する構文ノードは <code>ast.Expr</code> インタフェースを実装しています。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Expr">go/ast.Expr</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Expr</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">Node</span>
    <span class="tok-nx">exprNode</span><span class="tok-p">()</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.Expr</code> は（埋め込まれている <code>ast.Node</code> を除けば）外部に公開されないメソッドで構成されています。そのため、<code>ast</code> パッケージ外の型が <code>ast.Expr</code> を実装することはありません。</p>
</div>
<div class="paragraph">
<p><code>exprNode()</code> は実際にはどこからも呼ばれないメソッドです。そのため、<code>ast.Expr</code> はその振る舞いに関する情報を提供しない、分類用のインタフェースであるといえます。同様に、文や宣言に対応するインタフェース（<code>ast.Stmt</code> と <code>ast.Decl</code>）も定義されています。埋め込まれている <code>ast.Node</code> インタフェースも含め、これらについて詳しくは<a href="#構文ノードの実装">構文ノードの実装</a>で見ます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ファイルの構文解析"><a class="anchor" href="#ファイルの構文解析"></a>1.2. ファイルの構文解析</h3>
<div class="paragraph">
<p>ここまで式の構文解析を例にとって見てきましたが、実践においては、Goのソースコードはファイルやパッケージの単位で扱うことが普通です。ここからはファイル全体を構文解析する方法を見ていきます。</p>
</div>
<div class="sect3">
<h4 id="ファイルの構造"><a class="anchor" href="#ファイルの構造"></a>1.2.1. ファイルの構造</h4>
<div class="paragraph">
<p>まず、Goのソースコードファイルの構造を確認しておきましょう。</p>
</div>
<div class="paragraph">
<p><a href="https://golang.org/ref/spec#Source_file_organization">The Go Programming Language Specification - Source file organization</a> によれば、ひとつのファイルの中には</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>パッケージ名</p>
</li>
<li>
<p><code>import</code> 節</p>
</li>
<li>
<p>値や関数などトップレベルの宣言</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>が、この順番で現れることになっています。</p>
</div>
</div>
<div class="sect3">
<h4 id="parser_parsefile"><a class="anchor" href="#parser_parsefile"></a>1.2.2. parser.ParseFile</h4>
<div class="paragraph">
<p>Goのソースコードファイルの構文解析を行うには <code>parser.ParseFile</code> を使用します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/parser#ParseFile">go/parser.ParseFile</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">filename</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">src</span> <span class="tok-kd">interface</span><span class="tok-p">{},</span> <span class="tok-nx">mode</span> <span class="tok-nx">Mode</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">f</span> <span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第二引数の <code>filename</code> と第三引数の <code>src</code> はふたつで一組になっていて、構文解析するソースコードを指定します。<code>src == nil</code> であるときは <code>filename</code> に指定されたファイルの内容をソースコードとして読み込みます。それ以外の場合は <code>src</code> をソースコードとして読み込み、<code>filename</code> はソースコードの位置情報にだけ使われます。<code>src</code> は <code>interface{}</code> ですが、指定できるのは <code>string</code>、<code>[]byte</code>、<code>io.Reader</code> のいずれかのみです。</p>
</div>
<div class="paragraph">
<p>第一引数の <code>fset</code> は構文解析によって得られた構文木のノードの詳細な位置情報を保持する <code>token.FileSet</code> 構造体へのポインタです。詳しくは<a href="#ソースコード中の位置">ソースコード中の位置</a>で説明しますが、基本的に <code>token.NewFileSet()</code> で得られるものを渡せば十分です。</p>
</div>
<div class="paragraph">
<p>最後の引数 <code>mode</code> では構文解析する範囲の指定などが行えます。後で<a href="#コメントとドキュメント">コメントとドキュメント</a>を扱うときに少し触れます。</p>
</div>
<div class="listingblock">
<div class="title">リスト 3. parsefile.go <span class="icon"><a class="image" href="https://play.golang.org/p/HGVqc1bczw" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">d</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">f</span><span class="tok-p">.</span><span class="tok-nx">Decls</span> <span class="tok-p">{</span>
        <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Print</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-nx">d</span><span class="tok-p">)</span>
        <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">()</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>
<span class="tok-s">import _ &quot;log&quot;</span>
<span class="tok-s">func add(n, m int) {}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>     0  *ast.GenDecl {
     1  .  TokPos: example.go:2:1
     2  .  Tok: import
     3  .  Lparen: -
     4  .  Specs: []ast.Spec (len = 1) {
     5  .  .  0: *ast.ImportSpec {
     6  .  .  .  Name: *ast.Ident {
     7  .  .  .  .  NamePos: example.go:2:8
     8  .  .  .  .  Name: "_"
     9  .  .  .  }
    10  .  .  .  Path: *ast.BasicLit {
    11  .  .  .  .  ValuePos: example.go:2:10
    12  .  .  .  .  Kind: STRING
    13  .  .  .  .  Value: "\"log\""
    14  .  .  .  }
    15  .  .  .  EndPos: -
    16  .  .  }
    17  .  }
    18  .  Rparen: -
    19  }

     0  *ast.FuncDecl {
     1  .  Name: *ast.Ident {
     2  .  .  NamePos: example.go:3:6
     3  .  .  Name: "add"
     4  .  .  Obj: *ast.Object {
     5  .  .  .  Kind: func
     6  .  .  .  Name: "add"
     7  .  .  .  Decl: *(obj @ 0)
     8  .  .  }
     9  .  }
    10  .  Type: *ast.FuncType {
    11  .  .  Func: example.go:3:1
    12  .  .  Params: *ast.FieldList {
    13  .  .  .  Opening: example.go:3:9
    14  .  .  .  List: []*ast.Field (len = 1) {
    15  .  .  .  .  0: *ast.Field {
    16  .  .  .  .  .  Names: []*ast.Ident (len = 2) {
    17  .  .  .  .  .  .  0: *ast.Ident {
    18  .  .  .  .  .  .  .  NamePos: example.go:3:10
    19  .  .  .  .  .  .  .  Name: "n"
    20  .  .  .  .  .  .  .  Obj: *ast.Object {
    21  .  .  .  .  .  .  .  .  Kind: var
    22  .  .  .  .  .  .  .  .  Name: "n"
    23  .  .  .  .  .  .  .  .  Decl: *(obj @ 15)
    24  .  .  .  .  .  .  .  }
    25  .  .  .  .  .  .  }
    26  .  .  .  .  .  .  1: *ast.Ident {
    27  .  .  .  .  .  .  .  NamePos: example.go:3:13
    28  .  .  .  .  .  .  .  Name: "m"
    29  .  .  .  .  .  .  .  Obj: *ast.Object {
    30  .  .  .  .  .  .  .  .  Kind: var
    31  .  .  .  .  .  .  .  .  Name: "m"
    32  .  .  .  .  .  .  .  .  Decl: *(obj @ 15)
    33  .  .  .  .  .  .  .  }
    34  .  .  .  .  .  .  }
    35  .  .  .  .  .  }
    36  .  .  .  .  .  Type: *ast.Ident {
    37  .  .  .  .  .  .  NamePos: example.go:3:15
    38  .  .  .  .  .  .  Name: "int"
    39  .  .  .  .  .  }
    40  .  .  .  .  }
    41  .  .  .  }
    42  .  .  .  Closing: example.go:3:18
    43  .  .  }
    44  .  }
    45  .  Body: *ast.BlockStmt {
    46  .  .  Lbrace: example.go:3:20
    47  .  .  Rbrace: example.go:3:21
    48  .  }
    49  }</pre>
</div>
</div>
<div class="paragraph">
<p>例では <code>src</code> 変数のもつソースコードを構文解析し、トップレベルの宣言を印字します。今回は <code>import</code> 宣言が <code>*ast.GenDecl</code> として、関数 <code>func f</code> が <code>*ast.FuncDecl</code> として得られました。</p>
</div>
</div>
<div class="sect3">
<h4 id="ast_file"><a class="anchor" href="#ast_file"></a>1.2.3. ast.File</h4>
<div class="paragraph">
<p>ソースファイルは <code>ast.File</code> 構造体で表現され、パッケージ名やトップレベルの宣言の情報を含んでいます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#File">go/ast.File</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">File</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>        <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span>   <span class="tok-c1">// associated documentation; or nil</span>
    <span class="tok-nx">Package</span>    <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>       <span class="tok-c1">// position of &quot;package&quot; keyword</span>
    <span class="tok-nx">Name</span>       <span class="tok-o">*</span><span class="tok-nx">Ident</span>          <span class="tok-c1">// package name</span>
    <span class="tok-nx">Decls</span>      <span class="tok-p">[]</span><span class="tok-nx">Decl</span>          <span class="tok-c1">// top-level declarations; or nil</span>
    <span class="tok-nx">Scope</span>      <span class="tok-o">*</span><span class="tok-nx">Scope</span>          <span class="tok-c1">// package scope (this file only)</span>
    <span class="tok-nx">Imports</span>    <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ImportSpec</span>   <span class="tok-c1">// imports in this file</span>
    <span class="tok-nx">Unresolved</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Ident</span>        <span class="tok-c1">// unresolved identifiers in this file</span>
    <span class="tok-nx">Comments</span>   <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// list of all comments in the source file</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>他にもいろいろなフィールドがありますが、</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Package</code> は<a href="#ソースコード中の位置">ソースコード中の位置</a>、</p>
</li>
<li>
<p><code>Scope</code> と <code>Unresolved</code> は<a href="#スコープ">スコープ</a>、</p>
</li>
<li>
<p><code>Doc</code> と <code>Comments</code> は<a href="#コメントとドキュメント">コメントとドキュメント</a></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>で解説します。</p>
</div>
</div>
<div class="sect3">
<h4 id="構文木の探索"><a class="anchor" href="#構文木の探索"></a>1.2.4. 構文木の探索</h4>
<div class="paragraph">
<p><a href="#構文ノードのインタフェース">構文ノードのインタフェース</a>で述べたように、構文木のノードは <code>ast</code> パッケージのインタフェースとして得られます。そのため、具体的な内容を知るにはtype assertionやtype switchを用いなければなりません。これを手で丁寧に書いていくのは大変で間違いも起きがちですが、<code>ast.Inspect</code> 関数で構文ノードに対する（深さ優先）探索を行えます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Inspect">go/ast.Inspect</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">Inspect</span><span class="tok-p">(</span><span class="tok-nx">node</span> <span class="tok-nx">Node</span><span class="tok-p">,</span> <span class="tok-nx">f</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">Node</span><span class="tok-p">)</span> <span class="tok-kt">bool</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>node</code> から始まり、子ノードを再帰的に探索しつつにコールバック関数 <code>f</code> が呼ばれます。子ノードの探索を終えるごとに、引数 <code>nil</code> でコールバックが呼ばれます。コールバック関数では <code>false</code> を返すことで、そのノードの子供以下への探索を打ち切ることができます。</p>
</div>
<div class="paragraph">
<p>以下は先ほどのソースコードファイル中の識別子を一覧する例です。訪問したノードの具体的な型を知るために、type assertionをおこなっています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 4. listidents.go <span class="icon"><a class="image" href="https://play.golang.org/p/EroI4nTKot" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Inspect</span><span class="tok-p">(</span><span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">n</span> <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Node</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-nx">ident</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">n</span><span class="tok-p">.(</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Ident</span><span class="tok-p">);</span> <span class="tok-nx">ok</span> <span class="tok-p">{</span>
            <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Name</span><span class="tok-p">)</span>
        <span class="tok-p">}</span>
        <span class="tok-k">return</span> <span class="tok-kc">true</span>
    <span class="tok-p">})</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>
<span class="tok-s">import _ &quot;log&quot;</span>
<span class="tok-s">func add(n, m int) {}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>p
_
add
n
m
int</pre>
</div>
</div>
<div class="paragraph">
<p>パッケージ名（<code>p</code>）や変数名（<code>n</code>）などの識別子が構文木に含まれていることが確認できます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
もうひとつの方法として、<code>ast.Visitor</code> インタフェースを実装して <code>ast.Walk(v ast.Visitor, node ast.Node)</code> を使うこともできます。実際 <code>ast.Inspect</code> の内部では <code>ast.Walk</code> が使われています。
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="構文ノードの実装"><a class="anchor" href="#構文ノードの実装"></a>1.3. 構文ノードの実装</h3>
<div class="sect3">
<h4 id="ast_node"><a class="anchor" href="#ast_node"></a>1.3.1. ast.Node</h4>
<div class="paragraph">
<p>抽象構文木のノードに対応する構造体は、すべて <code>ast.Node</code> インタフェースを実装しています。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Node">go/ast.Node</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Node</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">Pos</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of first character belonging to the node</span>
    <span class="tok-nx">End</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of first character immediately after the node</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>定義を見れば分かるとおり、<code>ast.Node</code> インタフェース自身はその<a href="#ソースコード中の位置">ソースコード中の位置</a>を提供するだけであり、このままでは構文木に関する情報を得ることはできません。構文木を探索・操作するにはtype assertionやtype swtichによる具体的な型への変換が必要になります。</p>
</div>
<div class="paragraph">
<p>構文木のノードを大別するため、<code>ast.Node</code> を実装するサブインタフェースが定義されています：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ast.Decl</code></dt>
<dd>
<p>宣言（declaration）。<code>import</code> や <code>type</code> など</p>
</dd>
<dt class="hdlist1"><code>ast.Stmt</code></dt>
<dd>
<p>文（statement）。<code>if</code> や <code>switch</code> など</p>
</dd>
<dt class="hdlist1"><code>ast.Expr</code></dt>
<dd>
<p>式（expression）。識別子や演算、型など</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>ファイルやコメントなど、これらに分類されない構文ノードも存在します。</p>
</div>
<div class="paragraph">
<p>以下でこれらサブインタフェースと、その実装のうち主要なものを見ていきます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<a href="#ast_nodeの階層">ast.Nodeの階層</a>で <code>ast.Node</code> を実装する型の完全な一覧を確認できます。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="ast_decl"><a class="anchor" href="#ast_decl"></a>1.3.2. ast.Decl</h4>
<div class="paragraph">
<p><code>ast.Decl</code> インタフェースはGoソースコードにおける宣言（declaration）に対応する構文木のノードを表します。Goの宣言は</p>
</div>
<div class="ulist">
<ul>
<li>
<p>パッケージのインポート（<code>import</code>）</p>
</li>
<li>
<p>変数および定数（<code>var</code>、<code>const</code>）</p>
</li>
<li>
<p>型（<code>type</code>）</p>
</li>
<li>
<p>関数およびメソッド（<code>func</code>）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>と4種類に分けられますが、<code>ast.Decl</code> インタフェースを実装している構造体は <code>*ast.FuncDecl</code> と <code>*ast.GenDecl</code> の2つのみです。前者は名前どおり関数及びメソッドの宣言に相当し、後者が残りすべてをカバーします。</p>
</div>
<div class="sect4">
<h5 id="ast_funcdecl"><a class="anchor" href="#ast_funcdecl"></a>ast.FuncDecl</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#FuncDecl">go/ast.FuncDecl</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">FuncDecl</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>  <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// associated documentation; or nil</span>
    <span class="tok-nx">Recv</span> <span class="tok-o">*</span><span class="tok-nx">FieldList</span>    <span class="tok-c1">// receiver (methods); or nil (functions)</span>
    <span class="tok-nx">Name</span> <span class="tok-o">*</span><span class="tok-nx">Ident</span>        <span class="tok-c1">// function/method name</span>
    <span class="tok-nx">Type</span> <span class="tok-o">*</span><span class="tok-nx">FuncType</span>     <span class="tok-c1">// function signature: parameters, results, and position of &quot;func&quot; keyword</span>
    <span class="tok-nx">Body</span> <span class="tok-o">*</span><span class="tok-nx">BlockStmt</span>    <span class="tok-c1">// function body; or nil (forward declaration)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.FuncDecl</code> 構造体は関数の宣言に対応します。<code>Recv</code> フィールドはそのレシーバを表しており、これが <code>nil</code> である場合は関数を、そうでない場合はメソッドの宣言を表します。</p>
</div>
<div class="paragraph">
<p><code>Recv</code> の型である <a href="#ast.FieldList"><code>*ast.FieldList</code></a>は識別子と型の組のリストで、関数のパラメータや構造体のフィールドを表すのに使われます。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>FieldList</code> はその名の通り複数の組を表しますが、Goの文法上、レシーバとしてはただ1つの組のみが有効です。が構造体のフィールド宣言の表現などにも使われる <code>FieldList</code> が再利用されている形です。
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>上記の事情にも関わらず、<code>go/parser</code> は複数の組からなるレシーバをエラーなく解析します！ コメントによると、シンプルさとロバスト性のためだということです。</p>
</div>
<div class="paragraph">
<p>TODO: なんかいい感じに引用スタイル</p>
</div>
<div class="listingblock">
<div class="title">リスト 5. src/go/parser/parser.go</div>
<div class="content">
<pre>The parser accepts a larger language than is syntactically permitted by
the Go spec, for simplicity, and for improved robustness in the presence
of syntax errors. For instance, in method declarations, the receiver is
treated like an ordinary parameter list and thus may contain multiple
entries where the spec permits exactly one. Consequently, the corresponding
field in the AST (ast.FuncDecl.Recv) field is not restricted to one entry.</pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ast_gendecl"><a class="anchor" href="#ast_gendecl"></a>ast.GenDecl</h5>
<div class="paragraph">
<p>関数以外の宣言、<code>import</code>、<code>const</code>、<code>var</code>、<code>type</code> は <code>ast.GenDecl</code> がまとめて引き受けます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#GenDecl">go/ast.GenDecl</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">GenDecl</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>    <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// associated documentation; or nil</span>
    <span class="tok-nx">TokPos</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>     <span class="tok-c1">// position of Tok</span>
    <span class="tok-nx">Tok</span>    <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Token</span>   <span class="tok-c1">// IMPORT, CONST, TYPE, VAR</span>
    <span class="tok-nx">Lparen</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>     <span class="tok-c1">// position of &#39;(&#39;, if any</span>
    <span class="tok-nx">Specs</span>  <span class="tok-p">[]</span><span class="tok-nx">Spec</span>
    <span class="tok-nx">Rparen</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of &#39;)&#39;, if any</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Specs</code> フィールドはスライスであり、その要素がそれぞれ <code>ast.Spec</code> インタフェースであると定義されています。実際には、要素の具体的な型は <code>Tok</code> フィールドの値によってひとつに決まります。</p>
</div>
<table class="tableblock frame-all grid-all spread">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"><code>Tok</code> の値</th>
<th class="tableblock halign-left valign-top"><code>Specs</code> の要素の型</th>
<th class="tableblock halign-left valign-top">表す構文</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>token.IMPORT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*ast.ImportSpec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>import</code> 宣言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>token.CONST</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*ast.ValueSpec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>const</code> 宣言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>token.TYPE</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*ast.TypeSpec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>type</code> 宣言</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>token.VAR</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*ast.ValueSpec</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>var</code> 宣言</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>これらの宣言には、以下のようにグループ化できるという共通点があります。グループ化された宣言のひとつが <code>Specs</code> スライスのひとつの要素に対応します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;foo&quot;</span>
    <span class="tok-s">&quot;bar&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">a</span> <span class="tok-p">=</span> <span class="tok-mi">1</span>
    <span class="tok-nx">b</span> <span class="tok-p">=</span> <span class="tok-mi">2</span>
<span class="tok-p">)</span>

<span class="tok-kd">var</span> <span class="tok-p">(</span>
    <span class="tok-nx">x</span> <span class="tok-kt">int</span>
    <span class="tok-nx">y</span> <span class="tok-kt">bool</span>
<span class="tok-p">)</span>

<span class="tok-kd">type</span> <span class="tok-p">(</span>
    <span class="tok-nx">s</span> <span class="tok-kd">struct</span><span class="tok-p">{}</span>
    <span class="tok-nx">t</span> <span class="tok-kd">interface</span><span class="tok-p">{}</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ast_stmt"><a class="anchor" href="#ast_stmt"></a>1.3.3. ast.Stmt</h4>
<div class="paragraph">
<p><code>ast.Stmt</code> インタフェースはGoソースコードにおける <a href="https://golang.org/ref/spec#Statements">文</a> に対応する構文木のノードを表します。文はプログラムの実行を制御するもので、<code>go/ast</code> パッケージの実装では以下のように分類されています：</p>
</div>
<div class="ulist">
<div class="title">ast.Declの分類</div>
<ul>
<li>
<p>宣言（<code>ast.DeclStmt</code>）</p>
</li>
<li>
<p>空の文（<code>ast.EmptyStmt</code>）</p>
</li>
<li>
<p>ラベル付き文（<code>ast.LabeledStmt</code>）</p>
</li>
<li>
<p>式だけの文（<code>ast.ExprStmt</code>）</p>
</li>
<li>
<p>チャンネルへの送信（<code>ast.SendStmt</code>）</p>
</li>
<li>
<p>インクリメント・デクリメント（<code>ast.IncDecStmt</code>）</p>
</li>
<li>
<p>代入または定義（<code>ast.AssignStmt</code>）</p>
</li>
<li>
<p><code>go</code> （<code>ast.GoStmt</code>）</p>
</li>
<li>
<p><code>defer</code>（<code>ast.DeferStmt</code>）</p>
</li>
<li>
<p><code>return</code>（<code>ast.ReturnStmt</code>）</p>
</li>
<li>
<p><code>break</code>、<code>continue</code>、<code>goto</code>、<code>fallthrough</code>（<code>ast.BranchStmt</code>）</p>
</li>
<li>
<p>ブロック（<code>ast.BlockStmt</code>）</p>
</li>
<li>
<p><code>if</code>（<code>ast.IfStmt</code>）</p>
</li>
<li>
<p>式による <code>switch</code>（<code>ast.SwitchStmt</code>）</p>
</li>
<li>
<p>型による <code>switch</code>（<code>ast.TypeSwitchStmt</code>）</p>
</li>
<li>
<p><code>switch</code> 中のひとつの節（<code>ast.CaseClause</code>）</p>
</li>
<li>
<p><code>select</code>（<code>ast.SelectStmt</code>）</p>
</li>
<li>
<p><code>select</code> 中のひとつの節（<code>ast.CommClause</code>）</p>
</li>
<li>
<p><code>range</code> を含まない <code>for</code>（<code>ast.ForStmt</code>）</p>
</li>
<li>
<p><code>range</code> を含む <code>for</code>（<code>ast.RangeStmt</code>）</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="ast_switchstmt"><a class="anchor" href="#ast_switchstmt"></a>ast.SwitchStmt</h5>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><a href="https://golang.org/ref/spec#ExprSwitchStmt" class="bare">https://golang.org/ref/spec#ExprSwitchStmt</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Init</code> は <code>switch <strong>x := 1</strong>; t {</code></p>
</li>
<li>
<p><code>Tag</code> は <code>switch x := 1; <strong>t</strong> {</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="ast_typeswitchstmt"><a class="anchor" href="#ast_typeswitchstmt"></a>ast.TypeSwitchStmt</h5>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TODO</p>
</div>
<div class="paragraph">
<p><a href="https://golang.org/ref/spec#TypeSwitchStmt" class="bare">https://golang.org/ref/spec#TypeSwitchStmt</a></p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Init</code></p>
</li>
<li>
<p><code>Assign</code></p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ast_expr"><a class="anchor" href="#ast_expr"></a>1.3.4. ast.Expr</h4>
<div class="paragraph">
<p><code>ast.Expr</code> インタフェースはおもにGoソースコードにおける <a href="https://golang.org/ref/spec#Expressions">式</a> および <a href="https://golang.org/ref/spec#Types">型</a> に対応する構文木のノードを表します。<code>go/ast</code> パッケージの実装では以下のように分類されています：</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ast.Ellipsis</code> や <code>ast.KeyValueExpr</code> のように、それ単体では式となり得ないノードも <code>ast.Expr</code> を実装していますが、このおかげでこれらを含むノードの実装が簡単になっているようです。
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>識別子（<code>ast.Ident</code>）</p>
</li>
<li>
<p><code>&#8230;&#8203;</code>（<code>ast.Ellipsis</code>）</p>
</li>
<li>
<p>基本的な型のリテラル（<code>ast.BasicLit</code>）</p>
</li>
<li>
<p>関数リテラル（<code>ast.FuncLit</code>）</p>
</li>
<li>
<p><a href="https://golang.org/ref/spec#Composite_literals">複合リテラル</a>（<code>ast.CompositeLit</code>）</p>
</li>
<li>
<p>括弧（<code>ast.ParenExpr</code>）</p>
</li>
<li>
<p>セレクタまたは修飾された識別子（<code>x.y</code>）（<code>ast.SelectorExpr</code>）</p>
</li>
<li>
<p>添字アクセス（<code>ast.IndexExpr</code>）</p>
</li>
<li>
<p>スライス式（<code>ast.SliceExpr</code>）</p>
</li>
<li>
<p>型アサーション（<code>ast.TypeAssertExpr</code>）</p>
</li>
<li>
<p>関数またはメソッド呼び出し（<code>ast.CallExpr</code>）</p>
</li>
<li>
<p>ポインタの間接参照またはポインタ型（<code>*p</code>）（<code>ast.StarExpr</code>）</p>
</li>
<li>
<p>単項演算（<code>ast.UnaryExpr</code>）</p>
</li>
<li>
<p>二項演算（<code>ast.BinaryExpr</code>）</p>
</li>
<li>
<p>複合リテラル中のキーと値のペア（<code>key: value</code>）（<code>ast.KeyValueExpr</code>）</p>
</li>
<li>
<p>配列またはスライス型（<code>ast.ArrayType</code>）</p>
</li>
<li>
<p>構造体型（<code>ast.StructType</code>）</p>
</li>
<li>
<p>関数型（<code>ast.FuncType</code>）</p>
</li>
<li>
<p>インタフェース型（<code>ast.InterfaceType</code>）</p>
</li>
<li>
<p>マップ型（<code>ast.MapType</code>）</p>
</li>
<li>
<p>チャンネル型（<code>ast.ChanType</code>）</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="ast_ident"><a class="anchor" href="#ast_ident"></a>ast.Ident</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Ident">go/ast.Ident</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Ident</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">NamePos</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// identifier position</span>
    <span class="tok-nx">Name</span>    <span class="tok-kt">string</span>    <span class="tok-c1">// identifier name</span>
    <span class="tok-nx">Obj</span>     <span class="tok-o">*</span><span class="tok-nx">Object</span>   <span class="tok-c1">// denoted object; or nil</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.Ident</code> はコード中の識別子を表し、変数名をはじめパッケージ名、ラベルなどさまざまな場所に登場します。</p>
</div>
<div class="paragraph">
<p><code>Obj</code> フィールドはその実体を表す <code>ast.Object</code> への参照になっています。詳しくは <a href="#スコープとオブジェクト">スコープとオブジェクト</a>で触れます。</p>
</div>
</div>
<div class="sect4">
<h5 id="ast_structtypeとast_interfacetype"><a class="anchor" href="#ast_structtypeとast_interfacetype"></a>ast.StructTypeとast.InterfaceType</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#StructType">go/ast.StructType</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">StructType</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Struct</span>     <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>  <span class="tok-c1">// position of &quot;struct&quot; keyword</span>
    <span class="tok-nx">Fields</span>     <span class="tok-o">*</span><span class="tok-nx">FieldList</span> <span class="tok-c1">// list of field declarations</span>
    <span class="tok-nx">Incomplete</span> <span class="tok-kt">bool</span>       <span class="tok-c1">// true if (source) fields are missing in the Fields list</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#InterfaceType">go/ast.InterfaceType</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">InterfaceType</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Interface</span>  <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>  <span class="tok-c1">// position of &quot;interface&quot; keyword</span>
    <span class="tok-nx">Methods</span>    <span class="tok-o">*</span><span class="tok-nx">FieldList</span> <span class="tok-c1">// list of methods</span>
    <span class="tok-nx">Incomplete</span> <span class="tok-kt">bool</span>       <span class="tok-c1">// true if (source) methods are missing in the Methods list</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これら2つの構造体はそれぞれ構造体、インタフェースを表現します。また、<code>Incomplete</code> フィールドを持っています。これらは通常 <code>false</code> ですが、<a href="#ast.Filter">フィルタ</a>によってノード中のフィールドやメソッドの宣言が取り除かれる際に <code>true</code> となり、ソースコードとノードに乖離があることを示します。<code>go doc</code> が出力する &#8220;// Has unexported fields.&#8221; はこの値を参照しています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 6. structtypeincomplete.go <span class="icon"><a class="image" href="https://play.golang.org/p/28fDrrXZiR" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">structType</span> <span class="tok-o">:=</span> <span class="tok-nx">f</span><span class="tok-p">.</span><span class="tok-nx">Decls</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">].(</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">GenDecl</span><span class="tok-p">).</span><span class="tok-nx">Specs</span><span class="tok-p">[</span><span class="tok-mi">0</span><span class="tok-p">].(</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">TypeSpec</span><span class="tok-p">).</span><span class="tok-nx">Type</span><span class="tok-p">.(</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">StructType</span><span class="tok-p">)</span>

    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;fields=%#v incomplete=%#v\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">structType</span><span class="tok-p">.</span><span class="tok-nx">Fields</span><span class="tok-p">.</span><span class="tok-nx">List</span><span class="tok-p">,</span> <span class="tok-nx">structType</span><span class="tok-p">.</span><span class="tok-nx">Incomplete</span><span class="tok-p">)</span>

    <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">FileExports</span><span class="tok-p">(</span><span class="tok-nx">f</span><span class="tok-p">)</span>

    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;fields=%#v incomplete=%#v\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">structType</span><span class="tok-p">.</span><span class="tok-nx">Fields</span><span class="tok-p">.</span><span class="tok-nx">List</span><span class="tok-p">,</span> <span class="tok-nx">structType</span><span class="tok-p">.</span><span class="tok-nx">Incomplete</span><span class="tok-p">)</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>
<span class="tok-s">type S struct {</span>
<span class="tok-s">    Public  string</span>
<span class="tok-s">    private string</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>fields=[]*ast.Field{(*ast.Field)(0xc420016580), (*ast.Field)(0xc420016600)} incomplete=false
fields=[]*ast.Field{(*ast.Field)(0xc420016580)} incomplete=true</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="その他のノード"><a class="anchor" href="#その他のノード"></a>1.3.5. その他のノード</h4>
<div class="paragraph">
<p>以上の3種類に分類されないノードもいくつか存在します。</p>
</div>
<div class="sect4">
<h5 id="ast_commentとast_commentgroup"><a class="anchor" href="#ast_commentとast_commentgroup"></a>ast.Commentとast.CommentGroup</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Comment">go/ast.Comment</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Comment</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Slash</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of &quot;/&quot; starting the comment</span>
    <span class="tok-nx">Text</span>  <span class="tok-kt">string</span>    <span class="tok-c1">// comment text (excluding &#39;\n&#39; for //-style comments)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#CommentGroup">go/ast.CommentGroup</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">CommentGroup</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">List</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Comment</span> <span class="tok-c1">// len(List) &gt; 0</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.Comment</code> はひとつのコメント（<code>// &#8230;&#8203;</code> または <code>/* &#8230;&#8203; */</code>）に、<code>ast.CommentGroup</code> は連続するコメントに対応します。<a href="#コメントとドキュメント">コメントとドキュメント</a>で詳しく見ます。</p>
</div>
</div>
<div class="sect4">
<h5 id="ast_fieldとast_fieldlist"><a class="anchor" href="#ast_fieldとast_fieldlist"></a>ast.Fieldとast.FieldList</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Field">go/ast.Field</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Field</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>     <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// associated documentation; or nil</span>
    <span class="tok-nx">Names</span>   <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Ident</span>      <span class="tok-c1">// field/method/parameter names; or nil if anonymous field</span>
    <span class="tok-nx">Type</span>    <span class="tok-nx">Expr</span>          <span class="tok-c1">// field/method/parameter type</span>
    <span class="tok-nx">Tag</span>     <span class="tok-o">*</span><span class="tok-nx">BasicLit</span>     <span class="tok-c1">// field tag; or nil</span>
    <span class="tok-nx">Comment</span> <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// line comments; or nil</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#FieldList">go/ast.FieldList</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">FieldList</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Opening</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of opening parenthesis/brace, if any</span>
    <span class="tok-nx">List</span>    <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Field</span>  <span class="tok-c1">// field list; or nil</span>
    <span class="tok-nx">Closing</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of closing parenthesis/brace, if any</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>それぞれ、識別子と型の組ひとつ、そのリストに対応します。</p>
</div>
<div class="paragraph">
<p><code>ast.FieldList</code> は以下の構造体に含まれています：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ast.StructType</code>    &#8230;&#8203;&#8230;&#8203; 構造体のフィールドのリストとして</p>
</li>
<li>
<p><code>ast.InterfaceType</code> &#8230;&#8203;&#8230;&#8203; インタフェースのメソッドのリストとして</p>
</li>
<li>
<p><code>ast.FuncType</code>      &#8230;&#8203;&#8230;&#8203; 関数のパラメータおよび返り値として</p>
</li>
<li>
<p><code>ast.FuncDecl</code>      &#8230;&#8203;&#8230;&#8203; メソッドのレシーバとして</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ast.Field</code> の <code>Tag</code> は構造体のフィールドである場合のみ存在しえます。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO Names のふるまい方; nil と複数
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ast_nodeの階層"><a class="anchor" href="#ast_nodeの階層"></a>Appendix A: ast.Nodeの階層</h4>
<div class="listingblock">
<div class="content">
<pre>Node
  Decl
    *BadDecl
    *FuncDecl
    *GenDecl
  Expr
    *ArrayType
    *BadExpr
    *BasicLit
    *BinaryExpr
    *CallExpr
    *ChanType
    *CompositeLit
    *Ellipsis
    *FuncLit
    *FuncType
    *Ident
    *IndexExpr
    *InterfaceType
    *KeyValueExpr
    *MapType
    *ParenExpr
    *SelectorExpr
    *SliceExpr
    *StarExpr
    *StructType
    *TypeAssertExpr
    *UnaryExpr
  Spec
    *ImportSpec
    *TypeSpec
    *ValueSpec
  Stmt
    *AssignStmt
    *BadStmt
    *BlockStmt
    *BranchStmt
    *CaseClause
    *CommClause
    *DeclStmt
    *DeferStmt
    *EmptyStmt
    *ExprStmt
    *ForStmt
    *GoStmt
    *IfStmt
    *IncDecStmt
    *LabeledStmt
    *RangeStmt
    *ReturnStmt
    *SelectStmt
    *SendStmt
    *SwitchStmt
    *TypeSwitchStmt
  *Comment
  *CommentGroup
  *Field
  *FieldList
  *File
  *Package</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ソースコード中の位置"><a class="anchor" href="#ソースコード中の位置"></a>1.4. ソースコード中の位置</h3>
<div class="paragraph">
<p>ソースコードを対象とするプログラムがユーザにフィードバックを行う際は、以下の <code>go vet</code> の出力のように、ファイル名や行番号などソースコードにおける位置情報を含めるのが普通です。</p>
</div>
<div class="literalblock">
<div class="title">go vet の出力</div>
<div class="content">
<pre>% go vet github.com/motemen/gore
quickfix.go:76: go/ast.ExprStmt composite literal uses unkeyed fields</pre>
</div>
</div>
<div class="paragraph">
<p>以下では、このようなソースコード中の位置情報を扱うためのAPIを見ていきます。</p>
</div>
<div class="sect3">
<h4 id="token_pos"><a class="anchor" href="#token_pos"></a>1.4.1. token.Pos</h4>
<div class="paragraph">
<p>すべての抽象構文木のノードは<a href="#ast_node">ast.Node</a>インタフェースを実装しているのでした。<code>ast.Node</code> は <code>token.Pos</code> を返す <code>Pos()</code> と <code>End()</code> の2つのメソッドで構成されます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Node">go/ast.Node</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Node</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">Pos</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of first character belonging to the node</span>
    <span class="tok-nx">End</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of first character immediately after the node</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これらはその名とコメントの示すとおり、当該のノードがソースコード上に占める開始位置と終了位置を表しています。<code>token.Pos</code> の実体は基準位置からオフセットを示す <code>int</code> 型です。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/token#Pos">go/token.Pos</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Pos</span> <span class="tok-kt">int</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>オフセット値は <code>1</code> から始まるバイト単位の値です。特に、<code>token.Pos</code> のzero value（= <code>0</code>）には <code>token.NoPos</code> という特別な名前が与えられています。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/token#NoPos">go/token.NoPos</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-nx">NoPos</span> <span class="tok-nx">Pos</span> <span class="tok-p">=</span> <span class="tok-mi">0</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>CallExpr.Ellipsis</code> や <code>GenDecl.Lparen</code> においてなど、<code>token.NoPos</code> はその位置情報を持つ要素がソースコード中に存在しないことを意味する場合もあります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>token.Pos</code> は単なる整数値でしかないので、ファイル名や行番号などの詳細な情報をこれだけから得ることはできません。実はノードの持つこれらの位置情報は <code>token.FileSet</code> を基準にした相対的なものとしてエンコードされていて、完全な情報を復元するには <code>FileSet</code> と <code>Pos</code> を組み合わせる必要があります。<code>token.FileSet</code> はこれまでの例にも登場してきた（そして無視されてきた）<code>fset</code> と名づけられるデータです。</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
ここから分かるように、構文解析の際に与える <code>token.FileSet</code> によってノードの構造体の値は変化します。抽象構文木を扱うプログラムでは、構文解析によって得られたノードは常にその基準となる <code>token.FileSet</code> とともに保持しておく必要があります。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="token_fileset"><a class="anchor" href="#token_fileset"></a>1.4.2. token.FileSet</h4>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/token#FileSet">go/token.FileSet</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">FileSet</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// Has unexported fields.</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>token.FileSet</code> は、<code>go/parser</code> が生成する抽象構文木のノードの位置情報を一手に引きうけ、保持する構造体です。ノードの構造体が保持する位置情報は<a href="#token_pos">前項</a>で述べたように <code>token.FileSet</code> を基準にした相対的なもので、整数値としてエンコードされています。</p>
</div>
<div class="paragraph">
<p>名前の通り、<code>token.FileSet</code> が表すのは複数のソースファイルの集合です。ここでのファイルとは概念上のもので、ファイルシステム上に存在する必要はなく、またファイル名が重複していても問題ありません。</p>
</div>
<div class="paragraph">
<p>興味あるソースファイル集合に対して1つあれば十分なので、いちど <code>token.NewFileSet()</code> で生成した参照を保持しておくのが普通です。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/token#NewFileSet">go/token.NewFileSet</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">NewFileSet</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">FileSet</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>token.FileSet</code> は、構文要素の具体的な位置を参照するAPIで要求されます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>構文木のノードを生成する際に必要です。</p>
</li>
<li>
<p><a href="#ソースコードの文字列化">ソースコードの文字列化</a>に必要です。</p>
</li>
<li>
<p><a href="#ast_print">ast.Print</a>に渡すと、<code>token.Pos</code> がダンプされる際にファイル名と行番号、カラム位置が表示されます。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>token.FileSet</code> はファイルそれぞれについて、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ファイルの開始位置のオフセット</p>
</li>
<li>
<p>各行の長さ</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>をバイト単位で保持しており、整数値にエンコードされた位置情報から、次に見る完全な位置情報を復元できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="token_position"><a class="anchor" href="#token_position"></a>1.4.3. token.Position</h4>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/token#Position">go/token.Position</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Position</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Filename</span> <span class="tok-kt">string</span> <span class="tok-c1">// filename, if any</span>
    <span class="tok-nx">Offset</span>   <span class="tok-kt">int</span>    <span class="tok-c1">// offset, starting at 0</span>
    <span class="tok-nx">Line</span>     <span class="tok-kt">int</span>    <span class="tok-c1">// line number, starting at 1</span>
    <span class="tok-nx">Column</span>   <span class="tok-kt">int</span>    <span class="tok-c1">// column number, starting at 1 (byte count)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>token.Position</code> 構造体はファイル名、行番号、カラム位置を持ち、ソースコード中の位置としては最も詳細な情報を含みます。<code>String()</code> メソッドによってわかりやすい位置情報が得られます。</p>
</div>
<div class="listingblock">
<div class="title">リスト 7. positionstring.go <span class="icon"><a class="image" href="https://play.golang.org/p/lBJWYcUtVe" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Invalid position without file name:&quot;</span><span class="tok-p">,</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">{}.</span><span class="tok-nx">String</span><span class="tok-p">())</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Invalid position with file name:   &quot;</span><span class="tok-p">,</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">{</span><span class="tok-nx">Filename</span><span class="tok-p">:</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">}.</span><span class="tok-nx">String</span><span class="tok-p">())</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Valid position without file name:  &quot;</span><span class="tok-p">,</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">{</span><span class="tok-nx">Line</span><span class="tok-p">:</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-nx">Column</span><span class="tok-p">:</span> <span class="tok-mi">3</span><span class="tok-p">}.</span><span class="tok-nx">String</span><span class="tok-p">())</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-s">&quot;Valid position with file name:     &quot;</span><span class="tok-p">,</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">{</span><span class="tok-nx">Filename</span><span class="tok-p">:</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">Line</span><span class="tok-p">:</span> <span class="tok-mi">2</span><span class="tok-p">,</span> <span class="tok-nx">Column</span><span class="tok-p">:</span> <span class="tok-mi">3</span><span class="tok-p">}.</span><span class="tok-nx">String</span><span class="tok-p">())</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>Invalid position without file name: -
Invalid position with file name:    example.go
Valid position without file name:   2:3
Valid position with file name:      example.go:2:3</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="スコープとオブジェクト"><a class="anchor" href="#スコープとオブジェクト"></a>1.5. スコープとオブジェクト</h3>
<div class="paragraph">
<p>Goのソースコードにおいて名前はレキシカルスコープを持ち、その有効範囲は静的に決まります。構文解析のAPIにもスコープに関係するものがいくつか存在します。以下ではこれらについて簡単に見ていきます。</p>
</div>
<div class="sect3">
<h4 id="構文解析だけでは不十分な例"><a class="anchor" href="#構文解析だけでは不十分な例"></a>1.5.1. 構文解析だけでは不十分な例</h4>
<div class="paragraph">
<p>ただし、構文解析だけでは全ての名前を正しく解決できるわけではありません。</p>
</div>
<div class="paragraph">
<p>以下のプログラムには <code>T{k: 0}</code> という同じ形をしたコードが出現します。ここで <code>k</code> が指すものは一方ではトップレベルの定数、もう一方では構造体のフィールドと、それぞれ違ったものになります（<a href="https://github.com/golang/example/tree/master/gotypes"><code>go/types</code>: The Go Type Checker</a> より）。</p>
</div>
<div class="listingblock">
<div class="title">リスト 8. indeterminableident.go <span class="icon"><a class="image" href="https://play.golang.org/p/DEqNP5JAY-" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">p</span>

<span class="tok-kd">const</span> <span class="tok-nx">k</span> <span class="tok-p">=</span> <span class="tok-mi">0</span>

<span class="tok-kd">func</span> <span class="tok-nx">f1</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-kd">type</span> <span class="tok-nx">T</span> <span class="tok-p">[</span><span class="tok-mi">1</span><span class="tok-p">]</span><span class="tok-kt">int</span>
    <span class="tok-nx">_</span> <span class="tok-p">=</span> <span class="tok-nx">T</span><span class="tok-p">{</span><span class="tok-nx">k</span><span class="tok-p">:</span> <span class="tok-mi">0</span><span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-nx">f2</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-kd">type</span> <span class="tok-nx">T</span> <span class="tok-kd">struct</span><span class="tok-p">{</span> <span class="tok-nx">k</span> <span class="tok-kt">int</span> <span class="tok-p">}</span>
    <span class="tok-nx">_</span> <span class="tok-p">=</span> <span class="tok-nx">T</span><span class="tok-p">{</span><span class="tok-nx">k</span><span class="tok-p">:</span> <span class="tok-mi">0</span><span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>また、名前なしの <code>import</code> 文によって導入されたパッケージ名は構文解析だけでは判定できません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">import</span> <span class="tok-s">&quot;github.com/motemen/go-gitconfig&quot;</span> <span class="tok-c1">// gitconfig という名前が導入される</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これらも含めて正しく（Go言語の仕様通りに）名前のスコープを決定するには、意味解析の手続きを経なくてはなりません。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
このように、<code>go/ast</code> のAPIで得られるスコープの情報は不完全なもので、あくまでソースコードが構文的に誤りのないことを保証するものです。より正確で詳しい情報が知りたい場合には<a href="#型解析">型解析</a>を行います。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="スコープ"><a class="anchor" href="#スコープ"></a>1.5.2. スコープ</h4>
<div class="paragraph">
<p>Goのスコープはブロックにもとづいて作られます。ブレース（<code>{ &#8230;&#8203; }</code>）による明示的なブロックのほかにも、構文から作られるスコープがあります。<a href="https://golang.org/ref/spec#Declarations_and_scope">Declarations and scope - The Go Programming Language Specification</a> に述べられていますが、抄訳します：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>あらかじめ定義されている名前（<code>nil</code> や <code>int</code> など）はユニバースブロック（universe block）に属します。</p>
</li>
<li>
<p>トップレベルの定数、変数、関数（メソッドを除く）はパッケージブロック（package block）に属します。</p>
</li>
<li>
<p>インポートされたパッケージの名前は、それを含むファイルブロック（file block）に属します。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>go/ast</code> のAPIを使用してアクセスできるのは、ファイルブロックのスコープとパッケージブロックのスコープ（<a href="#パッケージ">パッケージ</a>）のみです。</p>
</div>
<div class="paragraph">
<p>構文解析によって得られたスコープは <code>ast.Scope</code> として表現されます：</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Scope">go/ast.Scope</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Scope</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Outer</span>   <span class="tok-o">*</span><span class="tok-nx">Scope</span>
    <span class="tok-nx">Objects</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">Object</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>スコープはその外側のスコープへの参照と、名前から<a href="#オブジェクト">オブジェクト</a>へのマッピングで構成されています。あるスコープはその内側のスコープの情報を保持していませんが、これはスコープが基本的に識別子の解決のために使われるものだからです。あるスコープに出現した識別子がどんなオブジェクトであるかを判定するには、子スコープの情報は不要であり、親スコープを辿ることによって解決されます。</p>
</div>
</div>
<div class="sect3">
<h4 id="オブジェクト"><a class="anchor" href="#オブジェクト"></a>1.5.3. オブジェクト</h4>
<div class="paragraph">
<p>ソースコード中の識別子を表す <code>ast.Ident</code> には、<code>*ast.Object</code> 型の <code>Obj</code> というフィールドが定義されていました。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Ident">go/ast.Ident</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Ident</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">NamePos</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// identifier position</span>
    <span class="tok-nx">Name</span>    <span class="tok-kt">string</span>    <span class="tok-c1">// identifier name</span>
    <span class="tok-nx">Obj</span>     <span class="tok-o">*</span><span class="tok-nx">Object</span>   <span class="tok-c1">// denoted object; or nil</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>go/ast</code> や <code>go/types</code> では、名前をつけられた言語上の要素（<dfn>named language entity</dfn>）をオブジェクト（<dfn>object</dfn>）と呼んでおり、構文上のオブジェクトはこの <code>ast.Object</code> によって表されています。</p>
</div>
<div class="paragraph">
<p><code>ast.Object</code> の <code>Decl</code> フィールドは、そのオブジェクトが宣言されたノードを表します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Object">go/ast.Object</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Object</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Kind</span> <span class="tok-nx">ObjKind</span>
    <span class="tok-nx">Name</span> <span class="tok-kt">string</span>      <span class="tok-c1">// declared name</span>
    <span class="tok-nx">Decl</span> <span class="tok-kd">interface</span><span class="tok-p">{}</span> <span class="tok-c1">// corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil</span>
    <span class="tok-nx">Data</span> <span class="tok-kd">interface</span><span class="tok-p">{}</span> <span class="tok-c1">// object-specific data; or nil</span>
    <span class="tok-nx">Type</span> <span class="tok-kd">interface</span><span class="tok-p">{}</span> <span class="tok-c1">// placeholder for type information; may be nil</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>構文上同じオブジェクトを指すと思わしき識別子に対応する <code>*ast.Ident</code> は、同じ <code>ast.Object</code> を共有します。</p>
</div>
<div class="listingblock">
<div class="title">リスト 9. astobject.go <span class="icon"><a class="image" href="https://play.golang.org/p/zW0Fb-qyWc" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Inspect</span><span class="tok-p">(</span><span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">n</span> <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Node</span><span class="tok-p">)</span> <span class="tok-kt">bool</span> <span class="tok-p">{</span>
        <span class="tok-k">if</span> <span class="tok-nx">ident</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-o">:=</span> <span class="tok-nx">n</span><span class="tok-p">.(</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Ident</span><span class="tok-p">);</span> <span class="tok-nx">ok</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Name</span> <span class="tok-o">==</span> <span class="tok-s">&quot;x&quot;</span> <span class="tok-p">{</span>
            <span class="tok-kd">var</span> <span class="tok-nx">decl</span> <span class="tok-kd">interface</span><span class="tok-p">{}</span>
            <span class="tok-k">if</span> <span class="tok-nx">ident</span> <span class="tok-o">!=</span> <span class="tok-kc">nil</span> <span class="tok-o">&amp;&amp;</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Obj</span> <span class="tok-o">!=</span> <span class="tok-kc">nil</span> <span class="tok-p">{</span>
                <span class="tok-nx">decl</span> <span class="tok-p">=</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Obj</span><span class="tok-p">.</span><span class="tok-nx">Decl</span>
            <span class="tok-p">}</span>
            <span class="tok-kd">var</span> <span class="tok-nx">kind</span> <span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">ObjKind</span>
            <span class="tok-k">if</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Obj</span> <span class="tok-o">!=</span> <span class="tok-kc">nil</span> <span class="tok-p">{</span>
                <span class="tok-nx">kind</span> <span class="tok-p">=</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Obj</span><span class="tok-p">.</span><span class="tok-nx">Kind</span>
            <span class="tok-p">}</span>
            <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%-17sobj=%-12p  kind=%s decl=%T\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">(</span><span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Pos</span><span class="tok-p">()),</span> <span class="tok-nx">ident</span><span class="tok-p">.</span><span class="tok-nx">Obj</span><span class="tok-p">,</span> <span class="tok-nx">kind</span><span class="tok-p">,</span> <span class="tok-nx">decl</span><span class="tok-p">)</span>
        <span class="tok-p">}</span>
        <span class="tok-k">return</span> <span class="tok-kc">true</span>
    <span class="tok-p">})</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">import x &quot;pkg&quot;</span>

<span class="tok-s">func f() {</span>
<span class="tok-s">    if x := x.f(); x != nil {</span>
<span class="tok-s">        x(func(x int) int { return x + 1 })</span>
<span class="tok-s">    }</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>example.go:3:8   obj=0x0           kind=bad decl=&lt;nil&gt;
example.go:6:8   obj=0xc4200620f0  kind=var decl=*ast.AssignStmt
example.go:6:13  obj=0x0           kind=bad decl=&lt;nil&gt;
example.go:6:20  obj=0xc4200620f0  kind=var decl=*ast.AssignStmt
example.go:7:9   obj=0xc4200620f0  kind=var decl=*ast.AssignStmt
example.go:7:16  obj=0xc420062140  kind=var decl=*ast.Field
example.go:7:36  obj=0xc420062140  kind=var decl=*ast.Field</pre>
</div>
</div>
<div class="paragraph">
<p><code>import</code> したパッケージ名としての <code>x</code>、定義された変数としての <code>x</code>、関数の仮引数名としての <code>x</code> がそれぞれ違った <code>Obj</code> をもち、文法的に同じものであれば <code>Obj</code> が同じものを指しています。</p>
</div>
<div class="paragraph">
<p><code>Kind</code> フィールドは <code>ObjKind</code> 型に定義されている値のいずれかを取り、オブジェクトの種類を表します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Bad">go/ast.Bad</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Bad</span> <span class="tok-nx">ObjKind</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span> <span class="tok-c1">// for error handling</span>
    <span class="tok-nx">Pkg</span>                <span class="tok-c1">// package</span>
    <span class="tok-nx">Con</span>                <span class="tok-c1">// constant</span>
    <span class="tok-nx">Typ</span>                <span class="tok-c1">// type</span>
    <span class="tok-nx">Var</span>                <span class="tok-c1">// variable</span>
    <span class="tok-nx">Fun</span>                <span class="tok-c1">// function or method</span>
    <span class="tok-nx">Lbl</span>                <span class="tok-c1">// label</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>パッケージ名、定数名、型名、変数名、関数名またはメソッド名に加え、ラベル名もオブジェクトとして扱われることがわかります。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>Object</code> には、<code>Data</code> や <code>Type</code> など、さらに詳しい情報を保持するために用意されているフィールドも存在します。しかし、先に述べたように構文解析だけでは完全な情報が得られないので、これらの詳しい情報が必要な場合には<a href="#型解析">型解析</a>のAPIを使用することになるでしょう。</p>
</div>
<div class="paragraph">
<p>ちなみに、現在 <code>Type</code> フィールドはどこからも利用されていないようです。</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="パッケージ"><a class="anchor" href="#パッケージ"></a>1.5.4. パッケージ</h4>
<div class="paragraph">
<p>Goでは、ひとつのディレクトリに配置された複数のソースファイルが集まって、ひとつのパッケージを構成します。パッケージを構成するソースコードに登場する名前は、すべてどこかで定義されている必要があるという意味において、解決できなければいけません。</p>
</div>
<div class="sect4">
<h5 id="ast_file_scopeとast_file_unresolved"><a class="anchor" href="#ast_file_scopeとast_file_unresolved"></a>ast.File.Scopeとast.File.Unresolved</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#File">go/ast.File</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">File</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>        <span class="tok-o">*</span><span class="tok-nx">CommentGroup</span>   <span class="tok-c1">// associated documentation; or nil</span>
    <span class="tok-nx">Package</span>    <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>       <span class="tok-c1">// position of &quot;package&quot; keyword</span>
    <span class="tok-nx">Name</span>       <span class="tok-o">*</span><span class="tok-nx">Ident</span>          <span class="tok-c1">// package name</span>
    <span class="tok-nx">Decls</span>      <span class="tok-p">[]</span><span class="tok-nx">Decl</span>          <span class="tok-c1">// top-level declarations; or nil</span>
    <span class="tok-nx">Scope</span>      <span class="tok-o">*</span><span class="tok-nx">Scope</span>          <span class="tok-c1">// package scope (this file only)</span>
    <span class="tok-nx">Imports</span>    <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ImportSpec</span>   <span class="tok-c1">// imports in this file</span>
    <span class="tok-nx">Unresolved</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Ident</span>        <span class="tok-c1">// unresolved identifiers in this file</span>
    <span class="tok-nx">Comments</span>   <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">CommentGroup</span> <span class="tok-c1">// list of all comments in the source file</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.File</code> 構造体の <code>Scope</code> フィールドは、当該のソースファイルのファイルスコープ（ファイルブロック）を表します。ここで解決できなかったものは <code>Unresolved</code> フィールドに記録されます。正しくコンパイルできるソースコードであれば、ここに入るのは</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>import</code> によってファイルスコープに導入される名前</p>
</li>
<li>
<p>同パッケージの他ファイルのトップレベルに定義されている名前</p>
</li>
<li>
<p>ユニバースブロックに定義されている名前</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>への参照になるはずです。</p>
</div>
</div>
<div class="sect4">
<h5 id="ast_package"><a class="anchor" href="#ast_package"></a>ast.Package</h5>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Package">go/ast.Package</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Package</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Name</span>    <span class="tok-kt">string</span>             <span class="tok-c1">// package name</span>
    <span class="tok-nx">Scope</span>   <span class="tok-o">*</span><span class="tok-nx">Scope</span>             <span class="tok-c1">// package scope across all files</span>
    <span class="tok-nx">Imports</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">Object</span> <span class="tok-c1">// map of package id -&gt; package object</span>
    <span class="tok-nx">Files</span>   <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">File</span>   <span class="tok-c1">// Go source files by filename</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>複数のソースファイルをまとめ、パッケージとして扱うものが <code>ast.Package</code> です。<code>Scope</code> はパッケージスコープを表し、各々のファイルのトップレベルに宣言された名前を格納します。<code>Imports</code> は <code>import</code> 宣言によって導入された名前を保持します。</p>
</div>
<div class="paragraph">
<p><code>ast.Package</code> は <code>ast.NewPackage</code> で生成されます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#NewPackage">go/ast.NewPackage</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">NewPackage</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">files</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">File</span><span class="tok-p">,</span> <span class="tok-nx">importer</span> <span class="tok-nx">Importer</span><span class="tok-p">,</span> <span class="tok-nx">universe</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Package</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第3引数の <code>importer ast.Importer</code> は、<code>import</code> されるパッケージパスから、それが導入するオブジェクトを（記録しつつ）返す関数を渡します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Importer">go/ast.Importer</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Importer</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">imports</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">Object</span><span class="tok-p">,</span> <span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">pkg</span> <span class="tok-o">*</span><span class="tok-nx">Object</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>go</code> 本体と同じ挙動をするという意味での <code>ast.Importer</code> のカノニカルな実装は提供されていません。パッケージファイルのインポートを解決するために、ビルド済みのオブジェクトファイルを読み込むAPIは提供されています（TODO: 後述）。これは型も含めたパッケージ情報の読み込みとなるため、文法レベルの情報を扱う <code>ast</code> パッケージの範疇を外れます。</p>
</div>
<div class="paragraph">
<p>第4引数の <code>universe *ast.Scope</code> には、パッケージの外側のスコープであるユニバーススコープを渡します。こちらについても、型におけるユニバーススコープの情報を得るAPIは存在しますが、抽象構文木のみのレベルのものはありません。</p>
</div>
<div class="paragraph">
<p>これらを正しく渡すことで完全な <code>ast.Package</code> を生成することができますが、正しい情報が必要な場合には<a href="#型解析">型解析</a>を行うことを考えたほうがよいでしょう。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO: golang/gddo の例
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="parser_parsedir"><a class="anchor" href="#parser_parsedir"></a>1.5.5. parser.ParseDir</h4>
<div class="paragraph">
<p>Goでは、ひとつのパッケージに属するソースコードファイルは同じディレクトリ直下に配置されます。これらを一度に構文解析し、<code>ast.Package</code> を生成するAPIもあります。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/parser#ParseDir">go/parser.ParseDir</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">ParseDir</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">filter</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">os</span><span class="tok-p">.</span><span class="tok-nx">FileInfo</span><span class="tok-p">)</span> <span class="tok-kt">bool</span><span class="tok-p">,</span> <span class="tok-nx">mode</span> <span class="tok-nx">Mode</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">pkgs</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Package</span><span class="tok-p">,</span> <span class="tok-nx">first</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この関数では <code>ast.NewPackage</code> で行われるような名前の解決は行われません。</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ParseDir</code> はひとつのディレクトリからひとつでなく複数のパッケージを返しうるAPIになっていますが、異常なことではありません。普通にコンパイルできるような構成においても、複数のパッケージがひとつのディレクトリに共在することはありえます（<a href="https://golang.org/cmd/go/#hdr-Test_packages">Test packages</a>）。
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="コメントとドキュメント"><a class="anchor" href="#コメントとドキュメント"></a>2. コメントとドキュメント</h2>
<div class="sectionbody">
<div class="paragraph">
<p>これまではプログラムの実行に関わるコード本体をプログラムから扱う方法について見てきました。この章ではGoソースコード中のコメントを扱っていきます。</p>
</div>
<div class="paragraph">
<p>コメントはドキュメントの記述にも使用されており、そのためのAPIも <code>go/doc</code> パッケージとして用意されています。</p>
</div>
<div class="sect2">
<h3 id="コメントの解析"><a class="anchor" href="#コメントの解析"></a>2.1. コメントの解析</h3>
<div class="paragraph">
<p><code>parser.ParseFile</code> の第4引数 <code>mode</code> に <code>parser.ParseComments</code> 定数を指定することで、構文解析の結果にコメントを含めることができます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/parser#ParseFile">go/parser.ParseFile</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">filename</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">src</span> <span class="tok-kd">interface</span><span class="tok-p">{},</span> <span class="tok-nx">mode</span> <span class="tok-nx">Mode</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">f</span> <span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">リスト 10. parsecomment.go <span class="icon"><a class="image" href="https://play.golang.org/p/uDWRwBuOQx" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseComments</span><span class="tok-p">)</span>

    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">c</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">f</span><span class="tok-p">.</span><span class="tok-nx">Comments</span> <span class="tok-p">{</span>
        <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%s: %q\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">.</span><span class="tok-nx">Position</span><span class="tok-p">(</span><span class="tok-nx">c</span><span class="tok-p">.</span><span class="tok-nx">Pos</span><span class="tok-p">()),</span> <span class="tok-nx">c</span><span class="tok-p">.</span><span class="tok-nx">Text</span><span class="tok-p">())</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`// Package p provides Add function</span>
<span class="tok-s">// ...</span>
<span class="tok-s">package p</span>

<span class="tok-s">// Add adds two ints.</span>
<span class="tok-s">func add(n, m int) int {</span>
<span class="tok-s">    return n + m</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>example.go:1:1: "Package p provides Add function\n...\n"
example.go:5:1: "Add adds two ints.\n"</pre>
</div>
</div>
<div class="paragraph">
<p>こうやって解析されたコメントは通常の構文木とは別に、<code>ast.File</code> 構造体の <code>Comments</code> フィールドに格納されます。<code>Comments</code> フィールドは <code>[]*ast.CommentGroup</code> として宣言されています。<code>ast.CommentGroup</code> は連続して続くコメントをひとまとめにしたもので、</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>/* &#8230;&#8203; */</code> 形式のコメントなら <code>/*</code> から <code>*/</code> まで</p>
</li>
<li>
<p><code>// &#8230;&#8203;</code> 形式なら <code>//</code> から行末まで</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>が、ひとつの <code>ast.Comment</code> に対応します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#CommentGroup">go/ast.CommentGroup</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">CommentGroup</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">List</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Comment</span> <span class="tok-c1">// len(List) &gt; 0</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/ast#Comment">go/ast.Comment</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Comment</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Slash</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of &quot;/&quot; starting the comment</span>
    <span class="tok-nx">Text</span>  <span class="tok-kt">string</span>    <span class="tok-c1">// comment text (excluding &#39;\n&#39; for //-style comments)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>例えばコメントが以下のように書かれていた場合、それぞれ <code>CommentGroup</code> は2つ生成され、それぞれ2個の <code>Comment</code> を持ちます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-c1">// foo</span>
<span class="tok-cm">/* bar */</span>

<span class="tok-c1">// baz</span>
<span class="tok-c1">// quux</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>コメントも <code>ast.Node</code> インタフェースを実装し、位置情報を保持しています。<a href="#ソースコードの文字列化">ソースコードの文字列化</a>の際は、この位置情報にもとづいてコメントが正しく挿入されるようになっています。</p>
</div>
</div>
<div class="sect2">
<h3 id="goにおけるドキュメント"><a class="anchor" href="#goにおけるドキュメント"></a>2.2. Goにおけるドキュメント</h3>
<div class="paragraph">
<p>Goではトップレベルの型や関数のすぐ直前のコメントがそのAPIのドキュメントである、と標準的に定められています（<a href="http://blog.golang.org/godoc-documenting-go-code">Godoc: documenting Go code</a>）。標準の <code>go doc</code> コマンドもこのルールに則ってドキュメントを表示します。</p>
</div>
<div class="literalblock">
<div class="title">go doc go/parser.ParseFile</div>
<div class="content">
<pre>% go doc go/parser.ParseFile
func ParseFile(fset *token.FileSet, filename string, src interface{}, mode Mode) (f *ast.File, err error)
    ParseFile parses the source code of a single Go source file and returns the
    corresponding ast.File node. The source code may be provided via the
    filename of the source file, or via the src parameter.
...</pre>
</div>
</div>
<div class="listingblock">
<div class="title">リスト 11. src/go/parser/interface.go</div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-c1">// ParseFile parses the source code of a single Go source file and returns</span>
<span class="tok-c1">// the corresponding ast.File node. The source code may be provided via</span>
<span class="tok-c1">// the filename of the source file, or via the src parameter.</span>
<span class="tok-c1">// ...</span>
<span class="tok-c1">//</span>
<span class="tok-kd">func</span> <span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">filename</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">src</span> <span class="tok-kd">interface</span><span class="tok-p">{},</span> <span class="tok-nx">mode</span> <span class="tok-nx">Mode</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">f</span> <span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span> <span class="tok-p">{</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="doc_package"><a class="anchor" href="#doc_package"></a>2.3. doc.Package</h3>
<div class="paragraph">
<p>Goパッケージの（ソースコードから生成される）ドキュメントは、<code>doc.Package</code> として表現されます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/doc#Package">go/doc.Package</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Package</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Doc</span>        <span class="tok-kt">string</span>
    <span class="tok-nx">Name</span>       <span class="tok-kt">string</span>
    <span class="tok-nx">ImportPath</span> <span class="tok-kt">string</span>
    <span class="tok-nx">Imports</span>    <span class="tok-p">[]</span><span class="tok-kt">string</span>
    <span class="tok-nx">Filenames</span>  <span class="tok-p">[]</span><span class="tok-kt">string</span>
    <span class="tok-nx">Notes</span>      <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">][]</span><span class="tok-o">*</span><span class="tok-nx">Note</span>

    <span class="tok-c1">// Deprecated: For backward compatibility Bugs is still populated,</span>
    <span class="tok-c1">// but all new code should use Notes instead.</span>
    <span class="tok-nx">Bugs</span> <span class="tok-p">[]</span><span class="tok-kt">string</span>

    <span class="tok-c1">// declarations</span>
    <span class="tok-nx">Consts</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Value</span>
    <span class="tok-nx">Types</span>  <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Type</span>
    <span class="tok-nx">Vars</span>   <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Value</span>
    <span class="tok-nx">Funcs</span>  <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Func</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>doc.Package</code> は <code>doc.New</code> 関数によって <code>ast.Package</code>（<a href="#パッケージ">パッケージ</a>）から生成されます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/doc#New">go/doc.New</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">New</span><span class="tok-p">(</span><span class="tok-nx">pkg</span> <span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Package</span><span class="tok-p">,</span> <span class="tok-nx">importPath</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">mode</span> <span class="tok-nx">Mode</span><span class="tok-p">)</span> <span class="tok-o">*</span><span class="tok-nx">Package</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ドキュメントに &#8220;New takes ownership of the AST pkg and may edit or overwrite it.&#8221; とある通り、<code>doc.New</code> は与えられた <code>pkg</code> を書き換えることがあります。
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>mode</code> パラメータの指定によって、非公開のAPIに関してもドキュメントを収集することができます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/doc#AllDecls">go/doc.AllDecls</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-c1">// extract documentation for all package-level declarations,</span>
    <span class="tok-c1">// not just exported ones</span>
    <span class="tok-nx">AllDecls</span> <span class="tok-nx">Mode</span> <span class="tok-p">=</span> <span class="tok-mi">1</span> <span class="tok-o">&lt;&lt;</span> <span class="tok-kc">iota</span>

    <span class="tok-c1">// show all embedded methods, not just the ones of</span>
    <span class="tok-c1">// invisible (unexported) anonymous fields</span>
    <span class="tok-nx">AllMethods</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="doc_packageのレイアウト"><a class="anchor" href="#doc_packageのレイアウト"></a>2.3.1. doc.Packageのレイアウト</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>doc.Package</code> 構造体はドキュメントの表示に都合のよいように、整理された状態で</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="例示のためのテスト"><a class="anchor" href="#例示のためのテスト"></a>2.4. 例示のためのテスト</h3>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>doc.Examples</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ソースコードの文字列化"><a class="anchor" href="#ソースコードの文字列化"></a>3. ソースコードの文字列化</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>go/printer</p>
</li>
<li>
<p>go/format</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="型解析"><a class="anchor" href="#型解析"></a>4. 型解析</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ここまで見てきたようなGoの抽象構文木を扱うAPIを知っていれば、Goプログラムを対象にしてできることの7割ほどは実現できたも同然です。しかし、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ソースコード中に登場する名前が定義された位置や、</p>
</li>
<li>
<p>ある型がインタフェースを実装しているか</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>など、プログラムの構造を越えたより高度な情報が必要になった場合は、<strong>型解析</strong>に手を出す必要があります。</p>
</div>
<div class="paragraph">
<p>この章では、Goパッケージの型チェックと型にまつわるデータ構造を提供する <code>go/types</code> パッケージのAPIを見ていきます。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>TODO</p>
</div>
<div class="ulist">
<ul>
<li>
<p>名前解決</p>
</li>
<li>
<p>定数畳み込み</p>
</li>
<li>
<p>型推論</p>
</li>
<li>
<p>その他構文的なチェック</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="型チェックを行う"><a class="anchor" href="#型チェックを行う"></a>4.1. 型チェックを行う</h3>
<div class="paragraph">
<p><code>types</code> パッケージによる型チェックは、<code>types.Config</code> 構造体の <code>Check</code> メソッドを呼ぶところから始まります。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Config.Check">go/types.Config.Check</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">conf</span> <span class="tok-o">*</span><span class="tok-nx">Config</span><span class="tok-p">)</span> <span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span><span class="tok-p">,</span> <span class="tok-nx">files</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">,</span> <span class="tok-nx">info</span> <span class="tok-o">*</span><span class="tok-nx">Info</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Package</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>files []ast.File</code> には、ひとつのパッケージを構成する構文解析されたファイル群を指定します。<a href="#ファイルの構文解析">ファイルの構文解析</a> で <code>files</code> の要素を生成した際に使用した <code>fset</code> も引数として渡します。</p>
</div>
<div class="paragraph">
<p>最後の引数である <code>info *types.Info</code> は、パッケージ内の型にまつわる詳細な情報を格納する先として指定します。単純に型チェックを行いたいだけの場合は <code>nil</code> でも構いません。</p>
</div>
<div class="listingblock">
<div class="title">リスト 12. typechecksimple.go <span class="icon"><a class="image" href="https://play.golang.org/p/szN-pDyXak" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span><span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">()}</span>

    <span class="tok-nx">pkg</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-s">&quot;path/to/pkg&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{</span><span class="tok-nx">f</span><span class="tok-p">},</span> <span class="tok-kc">nil</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">pkg</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;s&quot;</span><span class="tok-p">).</span><span class="tok-nx">Type</span><span class="tok-p">())</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">var s = &quot;Hello, world&quot;</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package p ("path/to/pkg")
string</pre>
</div>
</div>
<div class="paragraph">
<p>パッケージのトップレベルに定義された <code>s</code> という変数の型が <code>string</code> であるという情報が得られました。</p>
</div>
<div class="paragraph">
<p>このように、型チェックおよび型情報の取得は <code>Config</code> 構造体をエントリポイントとしてパッケージごとに行います。結果は <a href="#types_package">types.Package</a> 構造体と、ここでは登場しませんでしたが <a href="#types_info">types.Info</a> 構造体に格納されます。</p>
</div>
</div>
<div class="sect2">
<h3 id="パッケージのインポート"><a class="anchor" href="#パッケージのインポート"></a>4.2. パッケージのインポート</h3>
<div class="paragraph">
<p>先ほどの例では <code>Config.Importer</code> を設定していました。これは <code>types.Importer</code> という型を持つフィールドです。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Importer">go/types.Importer</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Importer</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-c1">// Import returns the imported package for the given import</span>
    <span class="tok-c1">// path, or an error if the package couldn&#39;t be imported.</span>
    <span class="tok-c1">// Two calls to Import with the same path return the same</span>
    <span class="tok-c1">// package.</span>
    <span class="tok-nx">Import</span><span class="tok-p">(</span><span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Package</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>types.Importer</code> は、パッケージのパスを解決し、そのパッケージに関する型レベルの情報を返すインタフェースです。具体的には、コンパイルされたパッケージオブジェクトを <code>GOPATH</code> から探し出し、解析するのが仕事です。</p>
</div>
<div class="paragraph">
<p>この具体的な実装を提供するのが <code>go/importer</code> パッケージです。<code>importer.Default()</code> は実行中のバイナリのコンパイラ（<code>runtime.Compiler</code>）に対応するインポートの実装を返します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/importer#Default">go/importer.Default</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-nx">Default</span><span class="tok-p">()</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Importer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下はパッケージを読み込み、そのパッケージが公開している名前および依存しているパッケージの情報を印字する例です。</p>
</div>
<div class="listingblock">
<div class="title">リスト 13. importer.go <span class="icon"><a class="image" href="https://play.golang.org/p/jdhTpuTc6k" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">pkg</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">().</span><span class="tok-nx">Import</span><span class="tok-p">(</span><span class="tok-s">&quot;log&quot;</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Names</span><span class="tok-p">())</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Imports</span><span class="tok-p">())</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>[Fatal Fatalf Fatalln Flags LUTC Ldate Llongfile Lmicroseconds Logger Lshortfile LstdFlags Ltime New Output Panic Panicf Panicln Prefix Print Printf Println SetFlags SetOutput SetPrefix init]
[package io ("io") package sync ("sync") package time ("time")]</pre>
</div>
</div>
<div class="paragraph">
<p>プログラムの型チェックにはインポートしているパッケージがどんな名前と型を提供するのか知る必要があるため、<code>Config</code> 構造体の <code>Importer</code> フィールドという形でその実装を指定します。</p>
</div>
</div>
<div class="sect2">
<h3 id="types_config"><a class="anchor" href="#types_config"></a>4.3. types.Config</h3>
<div class="paragraph">
<p><code>types.Config</code> 構造体が <code>go/types</code> パッケージのエントリポイントとなります。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Config">go/types.Config</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Config</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// If IgnoreFuncBodies is set, function bodies are not</span>
    <span class="tok-c1">// type-checked.</span>
    <span class="tok-nx">IgnoreFuncBodies</span> <span class="tok-kt">bool</span>

    <span class="tok-c1">// If FakeImportC is set, `import &quot;C&quot;` (for packages requiring Cgo)</span>
    <span class="tok-c1">// declares an empty &quot;C&quot; package and errors are omitted for qualified</span>
    <span class="tok-c1">// identifiers referring to package C (which won&#39;t find an object).</span>
    <span class="tok-c1">// This feature is intended for the standard library cmd/api tool.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// Caution: Effects may be unpredictable due to follow-up errors.</span>
    <span class="tok-c1">//          Do not use casually!</span>
    <span class="tok-nx">FakeImportC</span> <span class="tok-kt">bool</span>

    <span class="tok-c1">// If Error != nil, it is called with each error found</span>
    <span class="tok-c1">// during type checking; err has dynamic type Error.</span>
    <span class="tok-c1">// Secondary errors (for instance, to enumerate all types</span>
    <span class="tok-c1">// involved in an invalid recursive type declaration) have</span>
    <span class="tok-c1">// error strings that start with a &#39;\t&#39; character.</span>
    <span class="tok-c1">// If Error == nil, type-checking stops with the first</span>
    <span class="tok-c1">// error found.</span>
    <span class="tok-nx">Error</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span>

    <span class="tok-c1">// An importer is used to import packages referred to from</span>
    <span class="tok-c1">// import declarations.</span>
    <span class="tok-c1">// If the installed importer implements ImporterFrom, the type</span>
    <span class="tok-c1">// checker calls ImportFrom instead of Import.</span>
    <span class="tok-c1">// The type checker reports an error if an importer is needed</span>
    <span class="tok-c1">// but none was installed.</span>
    <span class="tok-nx">Importer</span> <span class="tok-nx">Importer</span>

    <span class="tok-c1">// If Sizes != nil, it provides the sizing functions for package unsafe.</span>
    <span class="tok-c1">// Otherwise &amp;StdSizes{WordSize: 8, MaxAlign: 8} is used instead.</span>
    <span class="tok-nx">Sizes</span> <span class="tok-nx">Sizes</span>

    <span class="tok-c1">// If DisableUnusedImportCheck is set, packages are not checked</span>
    <span class="tok-c1">// for unused imports.</span>
    <span class="tok-nx">DisableUnusedImportCheck</span> <span class="tok-kt">bool</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>各フィールドを調整することで、<code>Check()</code> による型チェックを行う際の挙動をカスタマイズできます。</p>
</div>
<div class="paragraph">
<p>特に、<code>Error func(err error)</code> は型チェックの際に生じたエラーを全て受け取るコールバックとして便利です。これが nil である場合、最初のエラーが起きた時点で型チェックが停止します。</p>
</div>
</div>
<div class="sect2">
<h3 id="型チェックのエラー"><a class="anchor" href="#型チェックのエラー"></a>4.4. 型チェックのエラー</h3>
<div class="paragraph">
<p>型チェック時のエラーは <code>types.Error</code> 構造体によって表現されます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Error">go/types.Error</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Error</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">Fset</span> <span class="tok-o">*</span><span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">FileSet</span> <span class="tok-c1">// file set for interpretation of Pos</span>
    <span class="tok-nx">Pos</span>  <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span>      <span class="tok-c1">// error position</span>
    <span class="tok-nx">Msg</span>  <span class="tok-kt">string</span>         <span class="tok-c1">// error message</span>
    <span class="tok-nx">Soft</span> <span class="tok-kt">bool</span>           <span class="tok-c1">// if set, error is &quot;soft&quot;</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>エラーの起きた位置情報に加え、<code>Soft</code> フィールドを持っています。このフィールドは、当該のエラーが「ソフト」であるかどうかを示します。ソフトなエラーは、型チェックそのものには影響を与えません。具体的には、以下のエラーです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>import</code> されたパッケージが使用されていない</p>
</li>
<li>
<p>定義された変数が使用されていない</p>
</li>
<li>
<p>ラベルが利用されていない・重複している</p>
</li>
<li>
<p><code>:=</code> の左辺に新しい変数が登場していない</p>
</li>
<li>
<p><code>init</code> 関数の本体が存在しない</p>
</li>
<li>
<p>C形式の <code>for</code> 文の後処理文で変数を定義しようとしている<br>
…… <code>for i := 0; i &lt; 10; i, j := i+1, i {</code> のような形。構文解析の時点では受けつけてしまいます</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下で、ソフトなエラーとそうでない重篤なエラーの例を確認できます。</p>
</div>
<div class="listingblock">
<div class="title">リスト 14. typecheckerrors.go <span class="icon"><a class="image" href="https://play.golang.org/p/GJ5RPbyr4K" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span>
        <span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">(),</span>
        <span class="tok-nx">Error</span><span class="tok-p">:</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">err</span> <span class="tok-kt">error</span><span class="tok-p">)</span> <span class="tok-p">{</span>
            <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;soft=%-5v %s\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">err</span><span class="tok-p">.(</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Error</span><span class="tok-p">).</span><span class="tok-nx">Soft</span><span class="tok-p">,</span> <span class="tok-nx">err</span><span class="tok-p">)</span>
        <span class="tok-p">},</span>
    <span class="tok-p">}</span>

    <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-o">:=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-s">&quot;path/to/pkg&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{</span><span class="tok-nx">f</span><span class="tok-p">},</span> <span class="tok-kc">nil</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">err</span><span class="tok-p">)</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">import &quot;log&quot;</span>

<span class="tok-s">func main() {</span>
<span class="tok-s">    var s, t string</span>
<span class="tok-s">    s + 1</span>
<span class="tok-s">    foo = 42</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>soft=false example.go:7:6: cannot convert 1 (untyped int constant) to string
soft=false example.go:8:2: undeclared name: foo
soft=true  example.go:6:9: t declared but not used
soft=true  example.go:3:8: "log" imported but not used
example.go:7:6: cannot convert 1 (untyped int constant) to string</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="パッケージの型情報"><a class="anchor" href="#パッケージの型情報"></a>4.5. パッケージの型情報</h3>
<div class="paragraph">
<p><code>types.Config.Check()</code> によって得られる型情報は、パッケージに対応する <code>types.Package</code> と、補助的で詳細な情報である <code>types.Info</code> で表現されます。</p>
</div>
<div class="sect3">
<h4 id="types_package"><a class="anchor" href="#types_package"></a>4.5.1. types.Package</h4>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Package">go/types.Package</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Package</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// Has unexported fields.</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>types.Package</code> 構造体は公開されたフィールドを持たないため、メソッドからアクセスします。</p>
</div>
<div class="paragraph">
<p>あまり意味のない例ですが、以下では <code>$GOROOT/src/cmd/cover</code> ディレクトリのソースコードの型チェックを行っています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 15. typechecknameandpath.go <span class="icon"><a class="image" href="https://play.golang.org/p/p6PF6GRqiW" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
    <span class="tok-s">&quot;path/filepath&quot;</span>
    <span class="tok-s">&quot;runtime&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">path</span> <span class="tok-o">:=</span> <span class="tok-s">&quot;cmd/cover&quot;</span>

    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">aPkgs</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseDir</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-nx">filepath</span><span class="tok-p">.</span><span class="tok-nx">Join</span><span class="tok-p">(</span><span class="tok-nx">runtime</span><span class="tok-p">.</span><span class="tok-nx">GOROOT</span><span class="tok-p">(),</span> <span class="tok-s">&quot;src&quot;</span><span class="tok-p">,</span> <span class="tok-nx">path</span><span class="tok-p">),</span> <span class="tok-kc">nil</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span><span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">()}</span>

    <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">aPkg</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">aPkgs</span> <span class="tok-p">{</span>
        <span class="tok-nx">files</span> <span class="tok-o">:=</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{}</span>
        <span class="tok-k">for</span> <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">f</span> <span class="tok-o">:=</span> <span class="tok-k">range</span> <span class="tok-nx">aPkg</span><span class="tok-p">.</span><span class="tok-nx">Files</span> <span class="tok-p">{</span>
            <span class="tok-nx">files</span> <span class="tok-p">=</span> <span class="tok-nb">append</span><span class="tok-p">(</span><span class="tok-nx">files</span><span class="tok-p">,</span> <span class="tok-nx">f</span><span class="tok-p">)</span>
        <span class="tok-p">}</span>
        <span class="tok-nx">pkg</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-nx">path</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-nx">files</span><span class="tok-p">,</span> <span class="tok-kc">nil</span><span class="tok-p">)</span>
        <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;path=%v name=%v\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Path</span><span class="tok-p">(),</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Name</span><span class="tok-p">())</span>
    <span class="tok-p">}</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>path=cmd/cover name=main
path=cmd/cover name=main_test</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="typesにおけるスコープ"><a class="anchor" href="#typesにおけるスコープ"></a>4.6. typesにおけるスコープ</h3>
<div class="paragraph">
<p><code>Path</code> や <code>Name</code> などの基本的な情報の他に有用なのは、解析されたパッケージのスコープ情報でしょう。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Package.Scope">go/types.Package.Scope</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">pkg</span> <span class="tok-o">*</span><span class="tok-nx">Package</span><span class="tok-p">)</span> <span class="tok-nx">Scope</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Scope">go/types.Scope</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Scope</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// Has unexported fields.</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>types.Scope</code> 構造体は型におけるスコープを表します。スコープは基本的に、そこに所属する名前から、それが表すオブジェクト（&#8594; <a href="#オブジェクト">オブジェクト</a>）へのマッピングであると考えられます。</p>
</div>
<div class="paragraph">
<p>スコープは階層構造になっていて、<code>Parent()</code> および <code>Child()</code> メソッドによりその親（ひとつ外側のスコープ）や子にアクセスできます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Scope.Parent">go/types.Scope.Parent</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">s</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span><span class="tok-p">)</span> <span class="tok-nx">Parent</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Scope.Child">go/types.Scope.Child</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">s</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span><span class="tok-p">)</span> <span class="tok-nx">Child</span><span class="tok-p">(</span><span class="tok-nx">i</span> <span class="tok-kt">int</span><span class="tok-p">)</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="ユニバーススコープ"><a class="anchor" href="#ユニバーススコープ"></a>4.6.1. ユニバーススコープ</h4>
<div class="paragraph">
<p>最も外側のスコープをユニバーススコープと呼ぶことは前に述べたとおりですが、<code>ast</code> パッケージと違い <code>types</code> パッケージにはこれが定義されています。</p>
</div>
<div class="paragraph">
<p>以下の例では、ユニバーススコープに定義されている名前を列挙しています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 16. typesuniverse.go <span class="icon"><a class="image" href="https://play.golang.org/p/JJV5RT5h_e" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Universe</span><span class="tok-p">.</span><span class="tok-nx">Names</span><span class="tok-p">())</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>[append bool byte cap close complex complex128 complex64 copy delete error false float32 float64 imag int int16 int32 int64 int8 iota len make new nil panic print println real recover rune string true uint uint16 uint32 uint64 uint8 uintptr]</pre>
</div>
</div>
<div class="paragraph">
<p>組み込みの関数や型がユニバーススコープに属していることが分かります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="typesにおけるオブジェクト"><a class="anchor" href="#typesにおけるオブジェクト"></a>4.7. typesにおけるオブジェクト</h3>
<div class="paragraph">
<p><code>types</code> パッケージにおけるオブジェクトは、<code>ast</code> パッケージにおけるそれと異なり、インタフェースとして表現されています。また、より詳しい情報を持ちます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Object">go/types.Object</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Object</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">Parent</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span> <span class="tok-c1">// scope in which this object is declared</span>
    <span class="tok-nx">Pos</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of object identifier in declaration</span>
    <span class="tok-nx">Pkg</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Package</span>  <span class="tok-c1">// nil for objects in the Universe scope and labels</span>
    <span class="tok-nx">Name</span><span class="tok-p">()</span> <span class="tok-kt">string</span>   <span class="tok-c1">// package local object name</span>
    <span class="tok-nx">Type</span><span class="tok-p">()</span> <span class="tok-nx">Type</span>     <span class="tok-c1">// object type</span>
    <span class="tok-nx">Exported</span><span class="tok-p">()</span> <span class="tok-kt">bool</span> <span class="tok-c1">// reports whether the name starts with a capital letter</span>
    <span class="tok-nx">Id</span><span class="tok-p">()</span> <span class="tok-kt">string</span>     <span class="tok-c1">// object id (see Id below)</span>

    <span class="tok-c1">// String returns a human-readable string of the object.</span>
    <span class="tok-nx">String</span><span class="tok-p">()</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Has unexported methods.</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ast.Object</code> における <code>Kind</code> フィールドに対応するものを持たないため、type switchでその種類を判別することになります。typesパッケージで表現されるオブジェクトの種類と、対応するデータ型は以下のようになっています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>組み込み関数（<code>*types.Builtin</code>）</p>
</li>
<li>
<p>定数（<code>*types.Const</code>）</p>
</li>
<li>
<p>関数（<code>*types.Func</code>）</p>
</li>
<li>
<p>ラベル（<code>*types.Label</code>）</p>
</li>
<li>
<p><code>nil</code> （<code>*types.Nil</code>）</p>
</li>
<li>
<p>インポートされたパッケージ（<code>*types.PkgName</code>）</p>
</li>
<li>
<p>宣言された型（<code>*types.TypeName</code>）</p>
</li>
<li>
<p>宣言された変数など（<code>*types.Var</code>）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これらについて、以下で見ていきます。</p>
</div>
<div class="sect3">
<h4 id="types_builtin"><a class="anchor" href="#types_builtin"></a>4.7.1. types.Builtin</h4>
<div class="paragraph">
<p>組み込み関数を表します。組み込み関数は決まった型を持たないため、<code>Type()</code> は invalid な型を返します。</p>
</div>
<div class="listingblock">
<div class="title">リスト 17. typesbuiltin.go <span class="icon"><a class="image" href="https://play.golang.org/p/0ZaB6DWlye" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">obj</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Universe</span><span class="tok-p">.</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;append&quot;</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%v (%T)\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">obj</span><span class="tok-p">,</span> <span class="tok-nx">obj</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Printf</span><span class="tok-p">(</span><span class="tok-s">&quot;%v (%T)\n&quot;</span><span class="tok-p">,</span> <span class="tok-nx">obj</span><span class="tok-p">.</span><span class="tok-nx">Type</span><span class="tok-p">(),</span> <span class="tok-nx">obj</span><span class="tok-p">.</span><span class="tok-nx">Type</span><span class="tok-p">())</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>builtin append (*types.Builtin)
invalid type (*types.Basic)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="types_const"><a class="anchor" href="#types_const"></a>4.7.2. types.Const</h4>
<div class="paragraph">
<p>定数を表します。<code>Val()</code> メソッドは、その定数値を表す <code>go/constant</code> パッケージの値を返します。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Const.Val">go/types.Const.Val</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">obj</span> <span class="tok-o">*</span><span class="tok-nx">Const</span><span class="tok-p">)</span> <span class="tok-nx">Val</span><span class="tok-p">()</span> <span class="tok-nx">constant</span><span class="tok-p">.</span><span class="tok-nx">Value</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://golang.org/ref/spec#Constant_expressions">定数式</a>は型チェック時に評価され、値としてオブジェクトに保持されます（TODO: 定数畳み込み）。</p>
</div>
<div class="listingblock">
<div class="title">リスト 18. typesconst.go <span class="icon"><a class="image" href="https://play.golang.org/p/6QfOZ6VFWX" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span><span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">()}</span>

    <span class="tok-nx">pkg</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-s">&quot;path/to/pkg&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{</span><span class="tok-nx">f</span><span class="tok-p">},</span> <span class="tok-kc">nil</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;c2&quot;</span><span class="tok-p">).(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Const</span><span class="tok-p">).</span><span class="tok-nx">Val</span><span class="tok-p">())</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">const (</span>
<span class="tok-s">    s = &quot;Hello, &quot; + &quot;world&quot;</span>
<span class="tok-s">    c1 = complex(iota, float64(len(s)))</span>
<span class="tok-s">    c2</span>
<span class="tok-s">)</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>(2 + 12i)</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="types_func"><a class="anchor" href="#types_func"></a>4.7.3. types.Func</h4>
<div class="paragraph">
<p>関数を表します。より詳細には、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>宣言された関数</p>
</li>
<li>
<p>具象メソッド</p>
</li>
<li>
<p>（インタフェースの）抽象メソッド</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>です。</p>
</div>
<div class="paragraph">
<p>以下で、それぞれの場合（トップレベルの関数 <code>F</code>、型 <code>*T</code> のメソッド <code>F</code>、インタフェース <code>I</code> のメソッド <code>F</code>）の出現を確認しています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 19. typesfunc.go <span class="icon"><a class="image" href="https://play.golang.org/p/jO77omVeV8" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span><span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">()}</span>

    <span class="tok-nx">pkg</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-s">&quot;path/to/pkg&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{</span><span class="tok-nx">f</span><span class="tok-p">},</span> <span class="tok-kc">nil</span><span class="tok-p">)</span>

    <span class="tok-c1">// type assersions for clarity</span>
    <span class="tok-kd">var</span> <span class="tok-p">(</span>
        <span class="tok-nx">objF</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Object</span> <span class="tok-p">=</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;F&quot;</span><span class="tok-p">).(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Func</span><span class="tok-p">)</span>
        <span class="tok-nx">objT</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Object</span> <span class="tok-p">=</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;T&quot;</span><span class="tok-p">).(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">TypeName</span><span class="tok-p">)</span>
        <span class="tok-nx">objI</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Object</span> <span class="tok-p">=</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;I&quot;</span><span class="tok-p">).(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">TypeName</span><span class="tok-p">)</span>
    <span class="tok-p">)</span> <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">objF</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">objT</span><span class="tok-p">.</span><span class="tok-nx">Type</span><span class="tok-p">().(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Named</span><span class="tok-p">).</span><span class="tok-nx">Method</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>                  <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">objI</span><span class="tok-p">.</span><span class="tok-nx">Type</span><span class="tok-p">().</span><span class="tok-nx">Underlying</span><span class="tok-p">().(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Interface</span><span class="tok-p">).</span><span class="tok-nx">Method</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span> <i class="conum" data-value="3"></i><b>(3)</b>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">func F() {}</span>

<span class="tok-s">type T struct{}</span>

<span class="tok-s">func (*T) F() {}</span>

<span class="tok-s">type I interface {</span>
<span class="tok-s">    F()</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>func path/to/pkg.F()
func (*path/to/pkg.T).F()
func (path/to/pkg.I).F()</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>パッケージスコープ内の名前にアクセスします。<code>F</code> はトップレベルの関数に、<code>T</code> および <code>I</code> は型名に対応するオブジェクトとして取得します。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>型 <code>T</code> に属する最初のメソッドとして、<code>T.F()</code> に対応するオブジェクトを取得します。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>型 <code>I</code> が指すインタフェース <code>interface { F() }</code> の最初の（抽象）メソッドとして、<code>I.F()</code> に対応するオブジェクトを取得します。</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>インタフェースの抽象メソッドと、それ以外の具象メソッドに対応するオブジェクトへアクセスする方法は微妙に異なりますが、これはあとの節で詳しく触れます。</p>
</div>
</div>
<div class="sect3">
<h4 id="types_pkgname"><a class="anchor" href="#types_pkgname"></a>4.7.4. types.PkgName</h4>
<div class="paragraph">
<p><code>import</code> 宣言によってインポートされたパッケージの名前を表します。</p>
</div>
<div class="paragraph">
<p><code>Imported()</code> メソッドで、インポートされたパッケージに関する情報を保持する <a href="#types_package"><code>types.Package</code> 構造体</a>を得られます。これは <code>Config.Check</code> で得られるのと同様のものです。</p>
</div>
<div class="paragraph">
<p>以下の例では、<code>fmtPkg</code> という名前でインポートした <code>fmt</code> パッケージと、同パッケージのエクスポートする <code>Errorf</code> 関数に対応するオブジェクトを取得しています。</p>
</div>
<div class="paragraph">
<p>インポートしたパッケージの名前はパッケージスコープではなくファイルスコープに導入されるため、後の節で説明する<a href="#types_info"><code>Info</code> 構造体</a>を使ってファイルスコープを取得しています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 20. typespkgname.go <span class="icon"><a class="image" href="https://play.golang.org/p/AIQENS7mLZ" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">main</span>

<span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-s">&quot;go/ast&quot;</span>
    <span class="tok-s">&quot;go/importer&quot;</span>
    <span class="tok-s">&quot;go/parser&quot;</span>
    <span class="tok-s">&quot;go/token&quot;</span>
    <span class="tok-s">&quot;go/types&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kd">func</span> <span class="tok-nx">main</span><span class="tok-p">()</span> <span class="tok-p">{</span>
    <span class="tok-nx">fset</span> <span class="tok-o">:=</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">NewFileSet</span><span class="tok-p">()</span>
    <span class="tok-nx">f</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseFile</span><span class="tok-p">(</span><span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-s">&quot;example.go&quot;</span><span class="tok-p">,</span> <span class="tok-nx">src</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">Mode</span><span class="tok-p">(</span><span class="tok-mi">0</span><span class="tok-p">))</span>

    <span class="tok-nx">conf</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Config</span><span class="tok-p">{</span><span class="tok-nx">Importer</span><span class="tok-p">:</span> <span class="tok-nx">importer</span><span class="tok-p">.</span><span class="tok-nx">Default</span><span class="tok-p">()}</span>

    <span class="tok-nx">info</span> <span class="tok-o">:=</span> <span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Info</span><span class="tok-p">{</span>
        <span class="tok-nx">Scopes</span><span class="tok-p">:</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Node</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">Scope</span><span class="tok-p">{},</span>
    <span class="tok-p">}</span>
    <span class="tok-nx">_</span><span class="tok-p">,</span> <span class="tok-nx">_</span> <span class="tok-p">=</span> <span class="tok-nx">conf</span><span class="tok-p">.</span><span class="tok-nx">Check</span><span class="tok-p">(</span><span class="tok-s">&quot;path/to/pkg&quot;</span><span class="tok-p">,</span> <span class="tok-nx">fset</span><span class="tok-p">,</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">File</span><span class="tok-p">{</span><span class="tok-nx">f</span><span class="tok-p">},</span> <span class="tok-o">&amp;</span><span class="tok-nx">info</span><span class="tok-p">)</span>

    <span class="tok-nx">objPkgName</span> <span class="tok-o">:=</span> <span class="tok-nx">info</span><span class="tok-p">.</span><span class="tok-nx">Scopes</span><span class="tok-p">[</span><span class="tok-nx">f</span><span class="tok-p">].</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;fmtPkg&quot;</span><span class="tok-p">).(</span><span class="tok-o">*</span><span class="tok-nx">types</span><span class="tok-p">.</span><span class="tok-nx">PkgName</span><span class="tok-p">)</span>

    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">objPkgName</span><span class="tok-p">)</span>
    <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Println</span><span class="tok-p">(</span><span class="tok-nx">objPkgName</span><span class="tok-p">.</span><span class="tok-nx">Imported</span><span class="tok-p">().</span><span class="tok-nx">Scope</span><span class="tok-p">().</span><span class="tok-nx">Lookup</span><span class="tok-p">(</span><span class="tok-s">&quot;Errorf&quot;</span><span class="tok-p">))</span>
<span class="tok-p">}</span>

<span class="tok-kd">var</span> <span class="tok-nx">src</span> <span class="tok-p">=</span> <span class="tok-s">`package p</span>

<span class="tok-s">import fmtPkg &quot;fmt&quot;</span>

<span class="tok-s">func main() {</span>
<span class="tok-s">    fmtPkg.Println(&quot;Hello, world&quot;)</span>
<span class="tok-s">}</span>
<span class="tok-s">`</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre>package fmtPkg ("fmt")
func fmt.Errorf(format string, a ...interface{}) error</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ファイル先頭の <code>package</code> 節で指定された名前はスコープに導入されないので、自パッケージの名前が <code>PkgName</code> の形で登場することはありません。
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="types_typename"><a class="anchor" href="#types_typename"></a>4.7.5. types.TypeName</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
TBD
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="types_var"><a class="anchor" href="#types_var"></a>4.7.6. types.Var</h4>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
TBD
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="types_info"><a class="anchor" href="#types_info"></a>4.8. types.Info</h3>
<div class="paragraph">
<p>さて、<code>types.Scope</code> のメソッドを使うことで、パッケージ中に登場した名前に関する情報をオブジェクトとして得ることは一応可能です。しかしこれだけでは、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>あるオブジェクトがどこで定義されたのか</p>
</li>
<li>
<p>ある式にどんな型が与えられたのか</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>などについて（ただちには）知ることができません。そこで <code>Check</code> 関数の最後の引数に渡す構造体、<code>types.Info</code> の出番となります。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Info">go/types.Info</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Info</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// Types maps expressions to their types, and for constant</span>
    <span class="tok-c1">// expressions, their values. Invalid expressions are omitted.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// For (possibly parenthesized) identifiers denoting built-in</span>
    <span class="tok-c1">// functions, the recorded signatures are call-site specific:</span>
    <span class="tok-c1">// if the call result is not a constant, the recorded type is</span>
    <span class="tok-c1">// an argument-specific signature. Otherwise, the recorded type</span>
    <span class="tok-c1">// is invalid.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// Identifiers on the lhs of declarations (i.e., the identifiers</span>
    <span class="tok-c1">// which are being declared) are collected in the Defs map.</span>
    <span class="tok-c1">// Identifiers denoting packages are collected in the Uses maps.</span>
    <span class="tok-nx">Types</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Expr</span><span class="tok-p">]</span><span class="tok-nx">TypeAndValue</span>

    <span class="tok-c1">// Defs maps identifiers to the objects they define (including</span>
    <span class="tok-c1">// package names, dots &quot;.&quot; of dot-imports, and blank &quot;_&quot; identifiers).</span>
    <span class="tok-c1">// For identifiers that do not denote objects (e.g., the package name</span>
    <span class="tok-c1">// in package clauses, or symbolic variables t in t := x.(type) of</span>
    <span class="tok-c1">// type switch headers), the corresponding objects are nil.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// For an anonymous field, Defs returns the field *Var it defines.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()</span>
    <span class="tok-nx">Defs</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Ident</span><span class="tok-p">]</span><span class="tok-nx">Object</span>

    <span class="tok-c1">// Uses maps identifiers to the objects they denote.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// For an anonymous field, Uses returns the *TypeName it denotes.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// Invariant: Uses[id].Pos() != id.Pos()</span>
    <span class="tok-nx">Uses</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Ident</span><span class="tok-p">]</span><span class="tok-nx">Object</span>

    <span class="tok-c1">// Implicits maps nodes to their implicitly declared objects, if any.</span>
    <span class="tok-c1">// The following node and object types may appear:</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">//    node               declared object</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">//    *ast.ImportSpec    *PkgName for dot-imports and imports without renames</span>
    <span class="tok-c1">//    *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)</span>
    <span class="tok-c1">//      *ast.Field         anonymous parameter *Var</span>
    <span class="tok-c1">//</span>
    <span class="tok-nx">Implicits</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Node</span><span class="tok-p">]</span><span class="tok-nx">Object</span>

    <span class="tok-c1">// Selections maps selector expressions (excluding qualified identifiers)</span>
    <span class="tok-c1">// to their corresponding selections.</span>
    <span class="tok-nx">Selections</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-o">*</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">SelectorExpr</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">Selection</span>

    <span class="tok-c1">// Scopes maps ast.Nodes to the scopes they define. Package scopes are not</span>
    <span class="tok-c1">// associated with a specific node but with all files belonging to a package.</span>
    <span class="tok-c1">// Thus, the package scope can be found in the type-checked Package object.</span>
    <span class="tok-c1">// Scopes nest, with the Universe scope being the outermost scope, enclosing</span>
    <span class="tok-c1">// the package scope, which contains (one or more) files scopes, which enclose</span>
    <span class="tok-c1">// function scopes which in turn enclose statement and function literal scopes.</span>
    <span class="tok-c1">// Note that even though package-level functions are declared in the package</span>
    <span class="tok-c1">// scope, the function scopes are embedded in the file scope of the file</span>
    <span class="tok-c1">// containing the function declaration.</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">// The following node types may appear in Scopes:</span>
    <span class="tok-c1">//</span>
    <span class="tok-c1">//    *ast.File</span>
    <span class="tok-c1">//    *ast.FuncType</span>
    <span class="tok-c1">//    *ast.BlockStmt</span>
    <span class="tok-c1">//    *ast.IfStmt</span>
    <span class="tok-c1">//    *ast.SwitchStmt</span>
    <span class="tok-c1">//    *ast.TypeSwitchStmt</span>
    <span class="tok-c1">//    *ast.CaseClause</span>
    <span class="tok-c1">//    *ast.CommClause</span>
    <span class="tok-c1">//    *ast.ForStmt</span>
    <span class="tok-c1">//    *ast.RangeStmt</span>
    <span class="tok-c1">//</span>
    <span class="tok-nx">Scopes</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-nx">ast</span><span class="tok-p">.</span><span class="tok-nx">Node</span><span class="tok-p">]</span><span class="tok-o">*</span><span class="tok-nx">Scope</span>

    <span class="tok-c1">// InitOrder is the list of package-level initializers in the order in which</span>
    <span class="tok-c1">// they must be executed. Initializers referring to variables related by an</span>
    <span class="tok-c1">// initialization dependency appear in topological order, the others appear</span>
    <span class="tok-c1">// in source order. Variables without an initialization expression do not</span>
    <span class="tok-c1">// appear in this list.</span>
    <span class="tok-nx">InitOrder</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">Initializer</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>types.Info</code> は型チェック中に得られた、詳細な情報を保持する構造体です。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="型の情報"><a class="anchor" href="#型の情報"></a>4.9. 型の情報</h3>
<div class="sect3">
<h4 id="types_type"><a class="anchor" href="#types_type"></a>4.9.1. types.Type</h4>

</div>
</div>
<div class="sect2">
<h3 id="types_objectの階層"><a class="anchor" href="#types_objectの階層"></a>Appendix B: types.Objectの階層</h3>
<div class="listingblock">
<div class="content">
<pre>go/types.Object
  *go/types.Builtin
  *go/types.Const
  *go/types.Func
  *go/types.Label
  *go/types.Nil
  *go/types.PkgName
  *go/types.TypeName
  *go/types.Var</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="types_typeの階層"><a class="anchor" href="#types_typeの階層"></a>Appendix C: types.Typeの階層</h3>
<div class="listingblock">
<div class="content">
<pre>go/types.Type
  *go/types.Array
  *go/types.Basic
  *go/types.Chan
  *go/types.Interface
  *go/types.Map
  *go/types.Named
  *go/types.Pointer
  *go/types.Signature
  *go/types.Slice
  *go/types.Struct
  *go/types.Tuple</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ビルド情報"><a class="anchor" href="#ビルド情報"></a>5. ビルド情報</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>go/build</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="高レベルのapi"><a class="anchor" href="#高レベルのapi"></a>6. 高レベルのAPI</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>tools/go/loader</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ソースコードを読む"><a class="anchor" href="#ソースコードを読む"></a>7. ソースコードを読む</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ここではGoプログラマに広く使われているツール類のソースコードを読むことで、実践においてどのようにAPIが利用されているかを見ていきます。ここで見るのはAPIの利用の仕方のベストプラクティスであるとともに、エンドユーザにどのようなインタフェースで機能を提供するべきかの実例でもあります。</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
FIXME: 全体的に雑
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="go_doc"><a class="anchor" href="#go_doc"></a>7.1. go doc</h3>
<div class="paragraph">
<p>"go doc" はパッケージのAPIのドキュメントを閲覧する機能を提供するサブコマンドです。
<code>go doc go/ast Node</code> のようにパッケージやシンボルを指定すると、そのドキュメントを表示します。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% go doc go/ast Node
type Node interface {
        Pos() token.Pos // position of first character belonging to the node
        End() token.Pos // position of first character immediately after the node
}
    All node types implement the Node interface.</pre>
</div>
</div>
<div class="paragraph">
<p>パッケージ名は完全なパスでなくてもよく、その場合はGOPATH以下からマッチするものを探してきます。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>% go doc template
package template // import "html/template"

Package template (html/template) implements data-driven templates for
...

% go doc ast.Node
package ast // import "go/ast"

type Node interface {
        Pos() token.Pos // position of first character belonging to the node
        End() token.Pos // position of first character immediately after the node
}
    All node types implement the Node interface.</pre>
</div>
</div>
<div class="paragraph">
<p>ソースは <code>src/cmd/doc/</code> 以下にあります。</p>
</div>
<div class="paragraph">
<p><code>go doc</code> が行う処理は以下のように分解できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>コマンドライン引数の解決</p>
</li>
<li>
<p>ソースコードの解析</p>
</li>
<li>
<p>ドキュメントの表示</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>これから、それぞれの処理について詳しく見ていきます。</p>
</div>
<div class="sect3">
<h4 id="引数の解決_code_parseargs_code"><a class="anchor" href="#引数の解決_code_parseargs_code"></a>7.1.1. 引数の解決（<code>parseArgs</code>）</h4>
<div class="paragraph">
<p><code>go doc</code> サブコマンドに与えられるコマンドライン引数は、ユーザの意図を表した以下のような形の文字列のリストになっています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 21. go doc -h</div>
<div class="content">
<pre>% go doc -h
Usage of [go] doc:
        go doc
        go doc &lt;pkg&gt;
        go doc &lt;sym&gt;[.&lt;method&gt;]
        go doc [&lt;pkg&gt;].&lt;sym&gt;[.&lt;method&gt;]
        go doc &lt;pkg&gt; &lt;sym&gt;[.&lt;method&gt;]</pre>
</div>
</div>
<div class="paragraph">
<p>さまざまな形式がありますが、大きく</p>
</div>
<div class="paragraph">
<p>最初に、引数で指定された要件にしたがってドキュメントの元となるソースコードを取得します。</p>
</div>
<div class="paragraph">
<p><code>go doc</code> への引数の与え方はさまざまで、パッケージを指定する方法には次の3パターンがあります：</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>カレントディレクトリのソースコードを対象にする（例：<code>go doc</code>）。</p>
</li>
<li>
<p>完全なパスで指定されたパッケージを対象にする（例：<code>go doc encoding/json</code>）。</p>
</li>
<li>
<p>指定されたパスの一部からパッケージを探しだす（例：<code>go doc json</code>）。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>これに加えて、パッケージ内のシンボルおよびそのメソッドも指定されることがあります。</p>
</div>
<div class="paragraph">
<p>カレントディレクトリを対象にする場合およびパッケージが指定されている場合（aおよびb）は、<code>go/build</code> のAPI <code>build.Import</code> を使って簡単にソースコードの所在を示す <code>build.Package</code> が得られます。</p>
</div>
<div class="paragraph">
<p>そうでない場合（c）、パスの一部が一致するパッケージを発見する必要があります。ここでも <code>go/build</code> のAPIを利用し、<code>build.Default.GOROOT</code> と <code>build.Default.GOPATH</code> 以下のディレクトリを探索します。<code>go doc</code> コマンドが実行された時点でこの探索のためのgoroutineが起動していて、すばやく結果を返せるようになっています。</p>
</div>
</div>
<div class="sect3">
<h4 id="ソースコードの解析_code_parsepackage_code"><a class="anchor" href="#ソースコードの解析_code_parsepackage_code"></a>7.1.2. ソースコードの解析（<code>parsePackage</code>）</h4>
<div class="paragraph">
<p>ドキュメント情報を得るためには、ソースコードを解析する必要があります。パッケージの情報が手元にあるので <code>parser.ParseDir</code> でディレクトリ内のファイルを一度に解析できますが、その際第3引数の <code>filter</code> を指定して <code>GoFiles</code> や <code>CgoFiles</code> に含まれないものを除去します。こうすることで、実行環境（<code>GOOS</code> や <code>GOARCH</code>）に合わせたソースコードのみを解析対象としています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">pkgs</span><span class="tok-p">,</span> <span class="tok-nx">err</span> <span class="tok-o">:=</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseDir</span><span class="tok-p">(</span><span class="tok-nx">fs</span><span class="tok-p">,</span> <span class="tok-nx">pkg</span><span class="tok-p">.</span><span class="tok-nx">Dir</span><span class="tok-p">,</span> <span class="tok-nx">include</span><span class="tok-p">,</span> <span class="tok-nx">parser</span><span class="tok-p">.</span><span class="tok-nx">ParseComments</span><span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>その後 <code>doc.New</code> して得られた <code>doc.Package</code> から <code>Package</code> 構造体を生成します。</p>
</div>
</div>
<div class="sect3">
<h4 id="ドキュメントの表示_code_pacakge_packagedoc_code_など"><a class="anchor" href="#ドキュメントの表示_code_pacakge_packagedoc_code_など"></a>7.1.3. ドキュメントの表示（<code>Pacakge.packageDoc</code> など）</h4>
<div class="paragraph">
<p><code>Package</code> 構造体の以下のメソッドがモードに応じて選ばれ、ユーザに表示される内容を生成します。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>packageDoc</code> &#8230;&#8203; パッケージのドキュメントを表示</p>
</li>
<li>
<p><code>symbolDoc</code>  &#8230;&#8203; シンボル（型、関数、メソッドなど）のドキュメントを表示</p>
</li>
<li>
<p><code>methodDoc</code>  &#8230;&#8203; ある型のメソッドのドキュメントを表示</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ドキュメントを表示するなかで対象のソースコードにおける定義が必要になった場合（<code>go doc go/ast File</code> など）、<code>format.Node</code> で生成されます。<code>ast.FuncDecl</code> を表示する際は <code>Body</code> フィールドに <code>nil</code> を代入することで、宣言のみが表示されるようにしています。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="gofmt"><a class="anchor" href="#gofmt"></a>7.2. gofmt</h3>
<div class="paragraph">
<p>Goにおいて特徴的なコマンドで、ソースコードを標準的なスタイルにフォーマットします。ほとんどのGoプログラマが利用しているコマンドです（たぶん）。</p>
</div>
<div class="sect3">
<h4 id="gofmtの主なインタフェース"><a class="anchor" href="#gofmtの主なインタフェース"></a>7.2.1. gofmtの主なインタフェース</h4>
<div class="paragraph">
<p>何もオプションを指定しない場合、gofmtは引数のファイルまたは標準入力をフォーマットして、標準出力に印字します。</p>
</div>
<div class="paragraph">
<p>よく利用されるのは <code>-w</code> で、これが指定された場合結果は引数のファイルを上書きするのに使われます。また <code>-d</code> では、入力の内容と結果の <code>diff</code> が表示されます。</p>
</div>
<div class="paragraph">
<p>ソースコードは <code>src/cmd/gofmt</code> 以下にあります。</p>
</div>
</div>
<div class="sect3">
<h4 id="ソースコードの印字"><a class="anchor" href="#ソースコードの印字"></a>7.2.2. ソースコードの印字</h4>
<div class="paragraph">
<p>gofmtのメインの処理はソースコードの整形と印字です。これを担当するのが <code>processFile</code>（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/internal.go#L75"><code>internal.go:75</code></a>）関数です。この関数は <code>go/source</code> パッケージの <code>format.Source</code> 関数とよく似ていて、違いは次以降の項で触れるソースコードの書き換えや標準入力の扱いなどです。</p>
</div>
<div class="paragraph">
<p>入力をソースコードとして解析するのが <code>parse</code> 関数（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/internal.go#L23"><code>internal.go:23</code></a>）で、内部では <code>parser.ParseFile</code> を利用しています。<code>fragmentOk</code> 引数が <code>true</code> である場合、宣言のリストや式などファイルとしては不完全なソースコードも解析できるよう、ソースコードの先頭に <code>package p;</code> を追加したり、ソースを <code>func _() { &#8230;&#8203; }</code> で囲んだりという処理がなされます。<code>gofmt</code> では標準入力からソースコードが与えられた場合にこのモードを使います。</p>
</div>
<div class="paragraph">
<p>こうやって得られた抽象構文木は <code>format</code> 関数（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/internal.go#L94"><code>internal.go:94</code></a>）により整形されます。実際の整形処理は <code>printer.printer</code> によって行われ、ノードの持つ<a href="#ソースコード中の位置">ソースコード中の位置</a>を利用して、入力を尊重しつつ標準のフォーマットにしたがってソースコードが文字列化されます。抽象構文木とは別に得られたコメントも、ここでソースコードに織り込まれます。</p>
</div>
</div>
<div class="sect3">
<h4 id="code_gofmt_s_code_ソースをシンプルにする"><a class="anchor" href="#code_gofmt_s_code_ソースをシンプルにする"></a>7.2.3. <code>gofmt -s</code>: ソースをシンプルにする</h4>
<div class="paragraph">
<p>通常gofmtが行うのはソースコードの整形のみで、抽象構文木の構造が変わるような変更を行いませんが、<code>-s</code> や  <code>-r</code> を指定することでより積極的なフォーマットが可能です。</p>
</div>
<div class="paragraph">
<p>このオプションが指定された場合、ソースコードの印字の前に <code>simplify(f *ast.File)</code> が呼び出され、構文木の書き換えが行われます。以下でその流れを見ていきましょう。</p>
</div>
<div class="paragraph">
<p>最初に <code>const ()</code> のような空の宣言が取り除かれます。これは <code>ast.File.Decls</code> を書き換えることで実現できます（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/simplify.go#L137-146"><code>simplify.go:137-146</code></a>）。</p>
</div>
<div class="paragraph">
<p>それから、構文木を辿って単純化が行われます。適用されるのは以下のルールになります。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>複合リテラルの単純化</p>
</li>
<li>
<p>スライスの単純化（<code>s[a:len(s)]</code> → <code>s[a:]</code>）</p>
</li>
<li>
<p>for/range文の単純化（<code>for _ = range</code> → <code>for range</code>）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>スライスとfor/range文の単純化は比較的単純な作業で、type assertionを利用しながら構文木を探索し、求める構造に合致するノードを発見します。合致した場合、消し去りたい部分を表すフィールドに <code>nil</code> を代入することで結果のソースコードから削除しています。</p>
</div>
<div class="paragraph">
<p>複合リテラルの単純化の内部で使用されているのが <code>func match(m map[string]reflect.Value, pattern, val reflect.Value) bool</code> 関数です（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/rewrite.go#L160"><code>rewrite.go:160</code></a>）。<code>match()</code> は構文ノード（<code>ast.Node</code>）への <code>reflect.Value</code> を2つ引数に取り、それらが一致するかをチェックします。</p>
</div>
<div class="paragraph">
<p><code>match()</code> には2種類のモードがあり、</p>
</div>
<div class="ulist">
<ul>
<li>
<p>引数 <code>m</code> が <code>nil</code> の場合は、2つの <code>reflect.Value</code> の表す <code>ast.Node</code> が同じ値であるかを再帰的にチェックします。</p>
<div class="ulist">
<ul>
<li>
<p>この際、<a href="#ソースコード中の位置">ソースコード中の位置</a>などの値が異なっていても基本的に無視します。</p>
</li>
</ul>
</div>
</li>
<li>
<p>引数 <code>m</code> が非 <code>nil</code> の場合には、<code>pattern</code> 引数の表すパターンに <code>val</code> が一致するかを見ます（後述）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>ここでは前者の場合のみが起こり、複合リテラルの外側と内側の型（を表す構文ノード）が等しい場合には内側の型を消去する、という処理を行っています。</p>
</div>
</div>
<div class="sect3">
<h4 id="code_gofmt_r_code_ソースを書き換える"><a class="anchor" href="#code_gofmt_r_code_ソースを書き換える"></a>7.2.4. <code>gofmt -r</code>: ソースを書き換える</h4>
<div class="paragraph">
<p>さらに高度な機能として、引数に指定されたパターンに従ってソースコードを書き換えることもできます。以下のように <code>-&gt;</code> を2つのGoの式で挟んだ形式によってコードの書き換え規則を指定します。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>gofmt -r 'a[b:len(a)] -&gt; a[b:]' ...</pre>
</div>
</div>
<div class="paragraph">
<p>書き換え規則の入力は、まず2つの <code>ast.Expr</code> として解釈されます（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/rewrite.go#L19-32"><code>rewrite.go:19-32</code></a>）。</p>
</div>
<div class="paragraph">
<p>実際の処理は <code>rewriteFile</code>（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/rewrite.go#L57-82"><code>rewrite.go:57-82</code></a>）です。内部では、構文木を表すデータ構造を <code>reflect</code> APIによって探索しながら <code>rewriteVal</code> で書き換えを行います（<a href="https://github.com/golang/go/blob/go1.6/src/cmd/gofmt/rewrite.go#L64-77"><code>rewrite.go:64-77</code></a>）。探索中に出現した構文ノードがパターンに一致した場合、マッチ結果とユーザの入力にしたがってノードを置き換えます。</p>
</div>
<div class="paragraph">
<p>前述のように、書き換えは書き換え元のパターン（<code>a[b:len(a)]</code>）と書き換え先（<code>a[b:]</code>）の組によって指定されます。パターンはGoの式になっていて、中でも小文字1文字からなる識別子は「ワイルドカード」として扱われ、任意の式にマッチします。例えば <code>a + b</code> というパターンは、以下のような式にマッチします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">f</span><span class="tok-p">.</span><span class="tok-nx">g</span><span class="tok-p">(</span><span class="tok-nx">x</span><span class="tok-p">)</span> <span class="tok-o">+</span> <span class="tok-s">&quot;y&quot;</span>       <span class="tok-c1">// a=f.g(x), b=&quot;y&quot;</span>
<span class="tok-p">(</span><span class="tok-mi">1</span> <span class="tok-o">/</span> <span class="tok-mi">2</span><span class="tok-p">)</span> <span class="tok-o">+</span> <span class="tok-p">(</span><span class="tok-mi">3</span> <span class="tok-o">+</span> <span class="tok-mi">4</span><span class="tok-p">)</span>  <span class="tok-c1">// a=(1 / 2), b=(3 + 4) および a=3, b=4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>2番目の例のように、パターンの探索は再帰的に行われます。パターンとの一致のチェックには、前述の <code>match</code> 関数を用います。ワイルドカードに一致した構文ノードは引数 <code>m</code> に格納され、その後のチェックと書き換え後のノードの生成に利用されます。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="stringer"><a class="anchor" href="#stringer"></a>7.3. stringer</h3>
<div class="paragraph">
<p><code>stringer</code> は定数の文字列化のためのコードを自動生成するコマンドです。以下のようにして入手できます。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>$ go get golang.org/x/tools/cmd/stringer</pre>
</div>
</div>
<div class="paragraph">
<p><code>go doc golang.org/x/tools/cmd/stringer</code> にある例を見るのが分かりやすいでしょう。以下のように定数を定義したソースコードを書いたとします。この定数を表示するため <code>fmt.Print(Uni)</code> などとしても、<code>2</code> と印字されるだけでどんな意味を持った値なのかの情報に欠けてしまっています。</p>
</div>
<div class="listingblock">
<div class="title">リスト 22. sushi.go <span class="icon"><a class="image" href="https://play.golang.org/p/4AKhfaOgQp" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">package</span> <span class="tok-nx">sushi</span>

<span class="tok-kd">type</span> <span class="tok-nx">Sushi</span> <span class="tok-kt">uint</span>

<span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Maguro</span> <span class="tok-nx">Sushi</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span>
    <span class="tok-nx">Ikura</span>
    <span class="tok-nx">Uni</span>
    <span class="tok-nx">Tamago</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>fmt</code> パッケージのメソッドは、値が <code>fmt.Stringer</code> インタフェースを満たしていればその <code>String()</code> メソッドを利用するので、ここで <code>Sushi.String()</code> が定数の名前を返すようにすればいいはずです。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/fmt#Stringer">fmt.Stringer</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Stringer</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">String</span><span class="tok-p">()</span> <span class="tok-kt">string</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>見るからに単調な作業になので、プログラム的に生成することを考えますよね。そこで <code>stringer</code> の出番です。以上のような内容のソースコード <code>sushi.go</code> に対して <code>stringer -type Sushi sushi.go</code> を実行すると、次のソースコードが <code>pill_string.go</code> として生成されます。</p>
</div>
<div id="sushi_string.go" class="listingblock">
<div class="title">リスト 23. sushi_string.go <span class="icon"><a class="image" href="https://play.golang.org/p/gfirJbaQVX" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-c1">// Code generated by &quot;stringer -type Sushi sushi.go&quot;; DO NOT EDIT</span>

<span class="tok-kn">package</span> <span class="tok-nx">sushi</span>

<span class="tok-kn">import</span> <span class="tok-s">&quot;fmt&quot;</span>

<span class="tok-kd">const</span> <span class="tok-nx">_Sushi_name</span> <span class="tok-p">=</span> <span class="tok-s">&quot;MaguroIkuraUniTamago&quot;</span>

<span class="tok-kd">var</span> <span class="tok-nx">_Sushi_index</span> <span class="tok-p">=</span> <span class="tok-p">[</span><span class="tok-o">...</span><span class="tok-p">]</span><span class="tok-kt">uint8</span><span class="tok-p">{</span><span class="tok-mi">0</span><span class="tok-p">,</span> <span class="tok-mi">6</span><span class="tok-p">,</span> <span class="tok-mi">11</span><span class="tok-p">,</span> <span class="tok-mi">14</span><span class="tok-p">,</span> <span class="tok-mi">20</span><span class="tok-p">}</span>

<span class="tok-kd">func</span> <span class="tok-p">(</span><span class="tok-nx">i</span> <span class="tok-nx">Sushi</span><span class="tok-p">)</span> <span class="tok-nx">String</span><span class="tok-p">()</span> <span class="tok-kt">string</span> <span class="tok-p">{</span>
    <span class="tok-k">if</span> <span class="tok-nx">i</span> <span class="tok-o">&gt;=</span> <span class="tok-nx">Sushi</span><span class="tok-p">(</span><span class="tok-nb">len</span><span class="tok-p">(</span><span class="tok-nx">_Sushi_index</span><span class="tok-p">)</span><span class="tok-o">-</span><span class="tok-mi">1</span><span class="tok-p">)</span> <span class="tok-p">{</span>
        <span class="tok-k">return</span> <span class="tok-nx">fmt</span><span class="tok-p">.</span><span class="tok-nx">Sprintf</span><span class="tok-p">(</span><span class="tok-s">&quot;Sushi(%d)&quot;</span><span class="tok-p">,</span> <span class="tok-nx">i</span><span class="tok-p">)</span>
    <span class="tok-p">}</span>
    <span class="tok-k">return</span> <span class="tok-nx">_Sushi_name</span><span class="tok-p">[</span><span class="tok-nx">_Sushi_index</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-p">]:</span><span class="tok-nx">_Sushi_index</span><span class="tok-p">[</span><span class="tok-nx">i</span><span class="tok-o">+</span><span class="tok-mi">1</span><span class="tok-p">]]</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>これで <code>Sushi</code> 型の値を文字列化したときの情報量が増しました。<code>fmt.Print(Uni)</code> は <code>Uni</code> を印字します。コードは複雑なことをしているように見えますが、基本的に値に対応する定数名を返しているだけです。</p>
</div>
<div class="sect3">
<h4 id="処理の流れ"><a class="anchor" href="#処理の流れ"></a>7.3.1. 処理の流れ</h4>
<div class="paragraph">
<p><code>stringer</code> は以下の流れでその仕事を行います。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>ディレクトリ名やファイル名の形で引数に指定されたソースコードを読み込む。</p>
</li>
<li>
<p>コード中から指定された型を発見し、文字列化のために必要な情報を収集する。</p>
</li>
<li>
<p>文字列化のためのソースコードを生成する。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>主だった処理は <code>Generator</code> という型のメソッドになっています。<code>Generator</code> は中に <code>Package</code> 型の構造体を保持していて、コードを解析して得られた情報</p>
</div>
</div>
<div class="sect3">
<h4 id="ソースのロード"><a class="anchor" href="#ソースのロード"></a>7.3.2. ソースのロード</h4>
<div class="paragraph">
<p>ソースコードとして引数には1つのディレクトリか複数のファイルが指定できますが、どちらの場合も <code>Generator.parsePackage</code>（<a href="https://github.com/golang/go/blob//x/tools/cmd/stringer/stringer.go#L231"><code>stringer.go:231</code></a>）を通ります。</p>
</div>
<div class="paragraph">
<p>ソースコードファイルのリストは構文解析されたのち、<code>go/types</code> のAPIで型チェックされます。この際、型の定義の情報も収集するようになっており、これが後の工程で必要になってきます。定義の情報は <code>map[*ast.Ident]types.Object</code> の形で保持され、ソースコード中に出現する識別子の、その言語上の役割や型などの情報が得られます。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/types#Object">go/types.Object</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Object</span> <span class="tok-kd">interface</span> <span class="tok-p">{</span>
    <span class="tok-nx">Parent</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Scope</span> <span class="tok-c1">// scope in which this object is declared</span>
    <span class="tok-nx">Pos</span><span class="tok-p">()</span> <span class="tok-nx">token</span><span class="tok-p">.</span><span class="tok-nx">Pos</span> <span class="tok-c1">// position of object identifier in declaration</span>
    <span class="tok-nx">Pkg</span><span class="tok-p">()</span> <span class="tok-o">*</span><span class="tok-nx">Package</span>  <span class="tok-c1">// nil for objects in the Universe scope and labels</span>
    <span class="tok-nx">Name</span><span class="tok-p">()</span> <span class="tok-kt">string</span>   <span class="tok-c1">// package local object name</span>
    <span class="tok-nx">Type</span><span class="tok-p">()</span> <span class="tok-nx">Type</span>     <span class="tok-c1">// object type</span>
    <span class="tok-nx">Exported</span><span class="tok-p">()</span> <span class="tok-kt">bool</span> <span class="tok-c1">// reports whether the name starts with a capital letter</span>
    <span class="tok-nx">Id</span><span class="tok-p">()</span> <span class="tok-kt">string</span>     <span class="tok-c1">// object id (see Id below)</span>

    <span class="tok-c1">// String returns a human-readable string of the object.</span>
    <span class="tok-nx">String</span><span class="tok-p">()</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Has unexported methods.</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="型の発見_code_generator_generate_code"><a class="anchor" href="#型の発見_code_generator_generate_code"></a>7.3.3. 型の発見（<code>Generator.generate()</code>）</h4>
<div class="paragraph">
<p>コマンドライン引数に指定された型名を、ソースコードから探し出します。</p>
</div>
<div class="paragraph">
<p>構文解析されたソースコードを走査し、<code>Generator.genDecl</code> で指定された名前の型を持つ定数の宣言グループを発見します。Goにおいて定数の宣言はグループ化でき、値や型を指定しない場合には、直前の値や型と同内容の宣言をしたものとみなされます（<a href="https://golang.org/ref/spec#Constant_declarations">Constant declarations</a>）。特に <code>iota</code> というキーワードを使って値を宣言することで、連続する値を持つ定数を宣言できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">const</span> <span class="tok-p">(</span>
    <span class="tok-nx">Maguro</span> <span class="tok-nx">Sushi</span> <span class="tok-p">=</span> <span class="tok-kc">iota</span>
    <span class="tok-nx">Ikura</span>
    <span class="tok-nx">Uni</span>
    <span class="tok-nx">Tamago</span>
<span class="tok-p">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>宣言された定数を発見したあと、前の段階で得られた型の定義を収集します。ここではその型が整数型であることをチェックし、その場合、名前や値を <code>Value</code> として登録します。</p>
</div>
</div>
<div class="sect3">
<h4 id="文字列化処理の生成"><a class="anchor" href="#文字列化処理の生成"></a>7.3.4. 文字列化処理の生成</h4>
<div class="paragraph">
<p>最後に、発見された定数の値と名前をもとに、定数の文字列化を提供するコードを生成します。</p>
</div>
<div class="paragraph">
<p>戦略として、値が連続する定数の文字列表現をひとつの長い文字列に連結し、定数の文字列化の際にはそのスライスを返すようにします。この部分のコード生成は単純な文字列連結で実現されています。</p>
</div>
<div class="paragraph">
<p>生成されるのは前述の <a href="#sushi_string.go">sushi_string.go <span class="icon"><a class="image" href="https://play.golang.org/p/gfirJbaQVX" target="_blank" rel="noopener"><i class="fa fa-play-circle-o" title="View in Go Playground"></i></a></span></a> のようなコードです。このソースコード文字列に対して <code>go/format.Source</code> を行って得られた文字列が、出力先のファイルに書き込まれます。ファイル名は、対象の型の名前と入力であるソースコードのディレクトリを元に <code>sushi_string.go</code> といった名前に決まります。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="goimports"><a class="anchor" href="#goimports"></a>7.4. goimports</h3>
<div class="paragraph">
<p><code>goimports</code> は与えられたソースコードを編集し、<code>import</code> 宣言の追加や削除忘れの面倒を見てくれるツールです。その際 <code>gofmt</code> 相当のことも行うので、<code>gofmt</code> 代わりに利用している人も多いのではないでしょうか。</p>
</div>
<div class="paragraph">
<p><code>goimports</code> は以下のコマンドで入手できます：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>go get golang.org/x/tools/cmd/goimports</pre>
</div>
</div>
<div class="sect3">
<h4 id="code_import_code_の解決"><a class="anchor" href="#code_import_code_の解決"></a>7.4.1. <code>import</code> の解決</h4>
<div class="paragraph">
<p><code>goimports</code> のメイン部分は <code>fixImports</code>（gosource:TODO）です。この関数は与えられた解析済みのソースコードから未解決の識別子を探しだし、必要なパッケージを <code>GOPATH</code> 以下から探しだして <code>import</code> 宣言を挿入します。</p>
</div>
<div class="paragraph">
<p>具体的に行っていることは：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>構文木を探索し、</p>
<div class="ulist">
<ul>
<li>
<p><code>x.y</code> の形の参照を収集する</p>
</li>
<li>
<p><code>import</code> 宣言によってファイルスコープに導入された名前を収集する</p>
<div class="ulist">
<ul>
<li>
<p><code>importPathToName</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>その後、</p>
<div class="ulist">
<ul>
<li>
<p>一度も参照されていない <code>import</code> 宣言を削除する</p>
</li>
<li>
<p>未解決の参照を修正できるパッケージを探し出す</p>
<div class="ulist">
<ul>
<li>
<p><code>findImport</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>上記のパッケージに対応する <code>import</code> 宣言を挿入する</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>という流れです。</p>
</div>
<div class="sect4">
<h5 id="構文木の探索_2"><a class="anchor" href="#構文木の探索_2"></a>構文木の探索</h5>
<div class="paragraph">
<p>構文木の探索は <code>ast.Walk</code> を使って実装されています。<code>goimports</code> 中では、 <code>ast.SelectorExpr</code> と <code>ast.ImportSpec</code> の2種類の構文要素が興味ある対象です。</p>
</div>
<div class="paragraph">
<p><code>ast.SelectorExpr</code> は <code>expr.sel</code> の形の式で、:セレクタ（<dfn>selector</dfn>）と呼ばれています。<code>expr</code> には任意の式が入り得ますが、ここではインポートされたパッケージの呼び出しを発見したいだけなので <code>expr</code> が識別子（<code>ast.Ident</code>）であるかのチェックを行っています。こうして発見されたパッケージ名へのセレクタのうち、<a href="#オブジェクト">オブジェクト</a>が未解決のものを収集します。</p>
</div>
<div class="paragraph">
<p><code>ast.ImportSpec</code> は <code>import</code> 宣言ひとつ分に対応します。例えば以下のような <code>import</code> 宣言には4つの <code>ImportSpec</code> が含まれています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">import</span> <span class="tok-p">(</span>
    <span class="tok-s">&quot;fmt&quot;</span>
    <span class="tok-p">.</span> <span class="tok-s">&quot;math&quot;</span>
    <span class="tok-nx">_</span> <span class="tok-s">&quot;net/http/pprof&quot;</span>
<span class="tok-p">)</span>

<span class="tok-kn">import</span> <span class="tok-nx">logPkg</span> <span class="tok-s">&quot;log&quot;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ここで注目すべきは名前なしの <code>import "fmt"</code> です。パッケージの <code>import</code> によってファイルに導入される名前は、そのインポートパスではなくパッケージ中の宣言に依ります：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kn">import</span> <span class="tok-s">&quot;github.com/motemen/go-astutil&quot;</span> <span class="tok-c1">// &quot;astutil&quot; という名前が導入される</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>この解決を行うのが <code>importPathToName</code> です。ここでは <code>go/build.Import</code> を利用してパッケージに相当するソースコードを <code>GOPATH</code> 以下から発見します。</p>
</div>
<div class="paragraph">
<p><code>go/build</code> は、<code>go build</code> コマンドが行うように、<code>GOOS</code> や <code>GOARCH</code> 環境変数、ビルドタグに基づいてパッケージやソースコードを探しだすためのAPIを提供します。</p>
</div>
<div class="paragraph">
<p>ロードに失敗した場合はインポートパスの末尾部分が代替として使用されます。</p>
</div>
</div>
<div class="sect4">
<h5 id="code_import_code_宣言の挿入"><a class="anchor" href="#code_import_code_宣言の挿入"></a><code>import</code> 宣言の挿入</h5>
<div class="paragraph">
<p>続いて、上記の過程で収集された未解決の識別子からパッケージを探し出し、<code>import</code> 宣言を挿入します。このメイン部分、パッケージを探索するのが <code>findImportGoPath</code> です。パッケージ名と、そのパッケージによって提供されているべき名前から、パッケージのインポートパスを探し出します。</p>
</div>
<div class="paragraph">
<p>最初に標準パッケージのAPIとの一致がチェックされます。これはあらかじめテーブルが生成されているので高速にマッチします。</p>
</div>
<div class="paragraph">
<p>その後、ユーザによってインストールされたパッケージが探索されます。パッケージは最初に <code>pkgIndexOnce.Do(loadPkgIndex)</code> でインデックスします。<code>go/build.Default.SrcDirs()</code> 以下の、Goのソースコードを格納しているディレクトリに対して先ほどの <code>importPathToName</code> でパッケージ名の解決を行ってテーブルを作ります。</p>
</div>
<div class="paragraph">
<p>こうやって生成されたテーブルに対し、期待する識別子を公開しているパッケージを探し出します。<code>build.ImportDir</code> で得られたディレクトリ中のファイルを解析して（<code>loadExportsGoPath</code>）、エクスポートされてるものを発見して突き合わせます。</p>
</div>
<div class="sect5">
<h6 id="code_vendoring_code_の対応"><a class="anchor" href="#code_vendoring_code_の対応"></a><code>vendoring</code> の対応</h6>
<div class="paragraph">
<p><code>vendor</code> ディレクトリまたは <code>internal</code> ディレクトリはその親ディレクトリからしかインポートできません。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>TODO: <code>canUse</code></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="guru"><a class="anchor" href="#guru"></a>7.5. guru</h3>

</div>
<div class="sect2">
<h3 id="gddo"><a class="anchor" href="#gddo"></a>7.6. gddo</h3>
<div class="paragraph">
<p><a href="https://godoc.org/">GoDoc.org</a>はサードパーティ製のものを含むGoライブラリのドキュメントを閲覧できるウェブサイトです。ここでは以下のようなURLでGitHubなどにホストされているGoライブラリにアクセスできます。</p>
</div>
<div class="paragraph">
<p><a href="http://godoc.org/github.com/motemen/go-gitconfig" class="bare">http://godoc.org/github.com/motemen/go-gitconfig</a></p>
</div>
<div class="paragraph">
<p>標準ライブラリのドキュメントも同じように閲覧できます。</p>
</div>
<div class="paragraph">
<p><a href="http://godoc.org/fmt" class="bare">http://godoc.org/fmt</a></p>
</div>
<div class="paragraph">
<p>ソースコードは<a href="https://github.com/golang/gddo" class="bare">https://github.com/golang/gddo</a>にホストされています（&#8220;gddo&#8221; は<strong>G</strong>o<strong>D</strong>oc<strong>D</strong>ot<strong>O</strong>rgの頭文字を取ったものです）。</p>
</div>
<div class="paragraph">
<p>gddoはユーザから見るとドキュメントを表示するだけのサイトですが、裏側でソースコードのクロールを行うなど複雑な機能を持ち合わせています。ここでは指定されたドキュメントの表示機能のみに絞ってソースコードを読んでみます。</p>
</div>
<div class="paragraph">
<p>この機能を受け持つのが <code>servePackage</code> です。HTTPリクエストにしたがってパッケージのドキュメントを返すのが <code>getDoc</code>（<a href="https://github.com/golang/go/blob/717c3ed/gddo-server/main.go#L74"><code>main.go:74</code></a>）で、<code>gddo/doc.Package</code> を返します。<code>gddo/doc.Package</code> はあるパッケージのドキュメントに相当し、パッケージの提供する関数や型とそのドキュメントなど、godoc.orgで閲覧できるドキュメントのHTMLを生成するのに必要な主要な情報を保持しています。インポートパスに基づいてRedisからパッケージのドキュメントを取り出しますが、データが存在しないか古い場合、外部にホストされているソースコードからドキュメントの生成に必要な情報を取得します。</p>
</div>
<div class="paragraph">
<p>リクエストされたパッケージは <code>crawlDoc</code> から <code>github.com/golang/gddo/doc.Get</code> を経由して呼び出される <code>github.com/golang/gddo/gosrc.Get</code> によって、そのパッケージがホストされているリモートのVCSから取得されます。</p>
</div>
<div class="paragraph">
<p><code>doc.Get</code> は解析済みのパッケージのドキュメントを返す。<code>gosrc.Get</code> は <code>gosrc.Directory</code> という仮想的なソースコードディレクトリを返します。それを変換するのが <code>newPackage</code>。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getStatic</code></p>
</li>
<li>
<p>&#8220;getStatic gets a diretory from a statically known service&#8221;</p>
</li>
<li>
<p>githubとか。gosrc/github.go</p>
</li>
<li>
<p>Directoryを得るnewPackage</p>
</li>
<li>
<p><code>getDynamic</code></p>
</li>
<li>
<p>getVCSDir（vcs.go）</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="外部サービスへの対応"><a class="anchor" href="#外部サービスへの対応"></a>7.6.1. 外部サービスへの対応</h4>
<div class="paragraph">
<p>GitHubやBitBucketなど有名どころでAPIも提供されているサービスに対しては、それぞれからソースコードを取得する処理が実装されています。</p>
</div>
<div class="paragraph">
<p>各サービスは <code>gosrc.service</code> 構造体として表現されます：</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/github.com/golang/gddo/gosrc#service">github.com/golang/gddo/gosrc.service</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">service</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">pattern</span>         <span class="tok-o">*</span><span class="tok-nx">regexp</span><span class="tok-p">.</span><span class="tok-nx">Regexp</span>
    <span class="tok-nx">prefix</span>          <span class="tok-kt">string</span>
    <span class="tok-nx">get</span>             <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">http</span><span class="tok-p">.</span><span class="tok-nx">Client</span><span class="tok-p">,</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Directory</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>
    <span class="tok-nx">getPresentation</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">http</span><span class="tok-p">.</span><span class="tok-nx">Client</span><span class="tok-p">,</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Presentation</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>
    <span class="tok-nx">getProject</span>      <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">http</span><span class="tok-p">.</span><span class="tok-nx">Client</span><span class="tok-p">,</span> <span class="tok-kd">map</span><span class="tok-p">[</span><span class="tok-kt">string</span><span class="tok-p">]</span><span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-o">*</span><span class="tok-nx">Project</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>get</code>、<code>getPresentation</code>、<code>getProject</code> はそれぞれ <code>Directory</code>、<code>Presentation</code>、<code>Project</code> 型の値を返します。</p>
</div>
<div class="paragraph">
<p><code>Directory</code> が主に利用される型となります。これはパッケージのインポートパスやパッケージを構成するファイル名を保持しています。</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/github.com/golang/gddo/gosrc#Directory">github.com/golang/gddo/gosrc.Directory</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Directory</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-c1">// The import path for this package.</span>
    <span class="tok-nx">ImportPath</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Import path of package after resolving go-import meta tags, if any.</span>
    <span class="tok-nx">ResolvedPath</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Import path prefix for all packages in the project.</span>
    <span class="tok-nx">ProjectRoot</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Name of the project.</span>
    <span class="tok-nx">ProjectName</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Project home page.</span>
    <span class="tok-nx">ProjectURL</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Version control system: git, hg, bzr, ...</span>
    <span class="tok-nx">VCS</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Version control: active or should be suppressed.</span>
    <span class="tok-nx">Status</span> <span class="tok-nx">DirectoryStatus</span>

    <span class="tok-c1">// Cache validation tag. This tag is not necessarily an HTTP entity tag.</span>
    <span class="tok-c1">// The tag is &quot;&quot; if there is no meaningful cache validation for the VCS.</span>
    <span class="tok-nx">Etag</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Files.</span>
    <span class="tok-nx">Files</span> <span class="tok-p">[]</span><span class="tok-o">*</span><span class="tok-nx">File</span>

    <span class="tok-c1">// Subdirectories, not guaranteed to contain Go code.</span>
    <span class="tok-nx">Subdirectories</span> <span class="tok-p">[]</span><span class="tok-kt">string</span>

    <span class="tok-c1">// Location of directory on version control service website.</span>
    <span class="tok-nx">BrowseURL</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Format specifier for link to source line. It must contain one %s (file URL)</span>
    <span class="tok-c1">// followed by one %d (source line number), or be empty string if not available.</span>
    <span class="tok-c1">// Example: &quot;%s#L%d&quot;.</span>
    <span class="tok-nx">LineFmt</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// Whether the repository of this directory is a fork of another one.</span>
    <span class="tok-nx">Fork</span> <span class="tok-kt">bool</span>

    <span class="tok-c1">// How many stars (for a GitHub project) or followers (for a BitBucket</span>
    <span class="tok-c1">// project) the repository of this directory has.</span>
    <span class="tok-nx">Stars</span> <span class="tok-kt">int</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Presentation</code> はプレゼンテーション用の機能で、<a href="http://go-talks.appspot.com/">go-talks.appspot.org</a>でのみ利用されているものです。</p>
</div>
<div class="paragraph">
<p><code>Project</code> は <code>Description</code> だけを持つ構造体で、Goのドキュメントレベルでパッケージの説明が得られなかった場合に、サービスで設定されている説明を利用するためのものです。</p>
</div>
<div class="paragraph">
<p>以下のサービスがあらかじめ実装されています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BitBucket（<code>bitbucket.go</code>）</p>
</li>
<li>
<p>Launchpad（<code>launchpad.go</code>）</p>
</li>
<li>
<p>Google（<code>google.go</code>）</p>
</li>
<li>
<p>GitHubおよびGist（<code>github.go</code>）</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="例_github"><a class="anchor" href="#例_github"></a>例：GitHub</h5>
<div class="listingblock">
<div class="title">リスト 24. <a href="https://github.com/golang/go/blob/75e3d37/:gddo/gosrc/github.go#L20"><code>github.go:20</code></a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-nx">addService</span><span class="tok-p">(</span><span class="tok-o">&amp;</span><span class="tok-nx">service</span><span class="tok-p">{</span>
    <span class="tok-nx">pattern</span><span class="tok-p">:</span>         <span class="tok-nx">regexp</span><span class="tok-p">.</span><span class="tok-nx">MustCompile</span><span class="tok-p">(</span><span class="tok-s">`^github\.com/(?P&lt;owner&gt;[a-z0-9A-Z_.\-]+)/(?P&lt;repo&gt;[a-z0-9A-Z_.\-]+)(?P&lt;dir&gt;/.*)?$`</span><span class="tok-p">),</span>
    <span class="tok-nx">prefix</span><span class="tok-p">:</span>          <span class="tok-s">&quot;github.com/&quot;</span><span class="tok-p">,</span>
    <span class="tok-nx">get</span><span class="tok-p">:</span>             <span class="tok-nx">getGitHubDir</span><span class="tok-p">,</span>
    <span class="tok-nx">getPresentation</span><span class="tok-p">:</span> <span class="tok-nx">getGitHubPresentation</span><span class="tok-p">,</span>
    <span class="tok-nx">getProject</span><span class="tok-p">:</span>      <span class="tok-nx">getGitHubProject</span><span class="tok-p">,</span>
<span class="tok-p">})</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getGitHubDir</code>（<a href="https://github.com/golang/go/blob/75e3d37/:github.com/golang/gddo/gosrc/github.go#L51"><code>github.go:51</code></a>）でわりとストレートにファイルを一覧してる。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="仮想的なソースコードディレクトリからドキュメントを生成する"><a class="anchor" href="#仮想的なソースコードディレクトリからドキュメントを生成する"></a>7.6.2. 仮想的なソースコードディレクトリからドキュメントを生成する</h4>
<div class="paragraph">
<p>メソッド <code>gddo/doc.newPackage</code> が、仮想的なソースコードディレクトリである <code>gosrc.Directory</code> からドキュメントである <code>gddo/doc.Package</code> を生成します。<code>gosrc.Directory</code> はインポートパスや、ファイル名とそのデータを全て保持しています。</p>
</div>
<div class="paragraph">
<p>ディレクトリに含まれるファイルは、すべてが必要なファイルであるとは限りません。例えば <code>spec_linux.go</code> と <code>spec_windows.go</code> は共存し得ないし、<code>_test.go</code> で終わるファイルはテスト用なのでドキュメントには不要です。また、ソースコード中のビルドタグもコンパイルやドキュメント生成にあたって留意しなくてはなりません。そこで <code>go/build</code> のAPIを利用します。</p>
</div>
<div class="paragraph">
<p><code>go/build</code> のAPIは、特定の <code>GOOS</code> や <code>GOARCH</code> 下で、あるパッケージを構成するソースコードを一覧するものでした。</p>
</div>
<div class="paragraph">
<p>通常はローカルのファイルシステムに対してファイルの探索を行うのですが、<code>build.Context</code> のファイルシステムへのアクセスに相当するフィールドを書き換えることで</p>
</div>
<div class="listingblock">
<div class="title">godoc: <a href="http://godoc.org/pkg/go/build#Context">go/build.Context</a></div>
<div class="content">
<pre class="pygments highlight"><code data-lang="go"><span></span><span class="tok-kd">type</span> <span class="tok-nx">Context</span> <span class="tok-kd">struct</span> <span class="tok-p">{</span>
    <span class="tok-nx">GOARCH</span>      <span class="tok-kt">string</span> <span class="tok-c1">// target architecture</span>
    <span class="tok-nx">GOOS</span>        <span class="tok-kt">string</span> <span class="tok-c1">// target operating system</span>
    <span class="tok-nx">GOROOT</span>      <span class="tok-kt">string</span> <span class="tok-c1">// Go root</span>
    <span class="tok-nx">GOPATH</span>      <span class="tok-kt">string</span> <span class="tok-c1">// Go path</span>
    <span class="tok-nx">CgoEnabled</span>  <span class="tok-kt">bool</span>   <span class="tok-c1">// whether cgo can be used</span>
    <span class="tok-nx">UseAllFiles</span> <span class="tok-kt">bool</span>   <span class="tok-c1">// use files regardless of +build lines, file names</span>
    <span class="tok-nx">Compiler</span>    <span class="tok-kt">string</span> <span class="tok-c1">// compiler to assume when computing target paths</span>

    <span class="tok-c1">// The build and release tags specify build constraints</span>
    <span class="tok-c1">// that should be considered satisfied when processing +build lines.</span>
    <span class="tok-c1">// Clients creating a new context may customize BuildTags, which</span>
    <span class="tok-c1">// defaults to empty, but it is usually an error to customize ReleaseTags,</span>
    <span class="tok-c1">// which defaults to the list of Go releases the current release is compatible with.</span>
    <span class="tok-c1">// In addition to the BuildTags and ReleaseTags, build constraints</span>
    <span class="tok-c1">// consider the values of GOARCH and GOOS as satisfied tags.</span>
    <span class="tok-nx">BuildTags</span>   <span class="tok-p">[]</span><span class="tok-kt">string</span>
    <span class="tok-nx">ReleaseTags</span> <span class="tok-p">[]</span><span class="tok-kt">string</span>

    <span class="tok-c1">// The install suffix specifies a suffix to use in the name of the installation</span>
    <span class="tok-c1">// directory. By default it is empty, but custom builds that need to keep</span>
    <span class="tok-c1">// their outputs separate can set InstallSuffix to do so. For example, when</span>
    <span class="tok-c1">// using the race detector, the go command uses InstallSuffix = &quot;race&quot;, so</span>
    <span class="tok-c1">// that on a Linux/386 system, packages are written to a directory named</span>
    <span class="tok-c1">// &quot;linux_386_race&quot; instead of the usual &quot;linux_386&quot;.</span>
    <span class="tok-nx">InstallSuffix</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// JoinPath joins the sequence of path fragments into a single path.</span>
    <span class="tok-c1">// If JoinPath is nil, Import uses filepath.Join.</span>
    <span class="tok-nx">JoinPath</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">elem</span> <span class="tok-o">...</span><span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-kt">string</span>

    <span class="tok-c1">// SplitPathList splits the path list into a slice of individual paths.</span>
    <span class="tok-c1">// If SplitPathList is nil, Import uses filepath.SplitList.</span>
    <span class="tok-nx">SplitPathList</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">list</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">[]</span><span class="tok-kt">string</span>

    <span class="tok-c1">// IsAbsPath reports whether path is an absolute path.</span>
    <span class="tok-c1">// If IsAbsPath is nil, Import uses filepath.IsAbs.</span>
    <span class="tok-nx">IsAbsPath</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-kt">bool</span>

    <span class="tok-c1">// IsDir reports whether the path names a directory.</span>
    <span class="tok-c1">// If IsDir is nil, Import calls os.Stat and uses the result&#39;s IsDir method.</span>
    <span class="tok-nx">IsDir</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-kt">bool</span>

    <span class="tok-c1">// HasSubdir reports whether dir is a subdirectory of</span>
    <span class="tok-c1">// (perhaps multiple levels below) root.</span>
    <span class="tok-c1">// If so, HasSubdir sets rel to a slash-separated path that</span>
    <span class="tok-c1">// can be joined to root to produce a path equivalent to dir.</span>
    <span class="tok-c1">// If HasSubdir is nil, Import uses an implementation built on</span>
    <span class="tok-c1">// filepath.EvalSymlinks.</span>
    <span class="tok-nx">HasSubdir</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">root</span><span class="tok-p">,</span> <span class="tok-nx">dir</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">rel</span> <span class="tok-kt">string</span><span class="tok-p">,</span> <span class="tok-nx">ok</span> <span class="tok-kt">bool</span><span class="tok-p">)</span>

    <span class="tok-c1">// ReadDir returns a slice of os.FileInfo, sorted by Name,</span>
    <span class="tok-c1">// describing the content of the named directory.</span>
    <span class="tok-c1">// If ReadDir is nil, Import uses ioutil.ReadDir.</span>
    <span class="tok-nx">ReadDir</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">dir</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">([]</span><span class="tok-nx">os</span><span class="tok-p">.</span><span class="tok-nx">FileInfo</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>

    <span class="tok-c1">// OpenFile opens a file (not a directory) for reading.</span>
    <span class="tok-c1">// If OpenFile is nil, Import uses os.Open.</span>
    <span class="tok-nx">OpenFile</span> <span class="tok-kd">func</span><span class="tok-p">(</span><span class="tok-nx">path</span> <span class="tok-kt">string</span><span class="tok-p">)</span> <span class="tok-p">(</span><span class="tok-nx">io</span><span class="tok-p">.</span><span class="tok-nx">ReadCloser</span><span class="tok-p">,</span> <span class="tok-kt">error</span><span class="tok-p">)</span>
<span class="tok-p">}</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="フロー解析"><a class="anchor" href="#フロー解析"></a>8. フロー解析</h2>
<div class="sectionbody">
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
WIP
</td>
</tr>
</table>
</div>
<div class="ulist">
<ul>
<li>
<p>tools/go/ssa</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version bc91bf0<br>
Last updated 2018-08-01 10:18:58 UTC
</div>
</div>
</body>
</html>