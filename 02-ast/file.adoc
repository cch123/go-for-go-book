= ファイルの構文解析

実践においては、Goのソースコードはファイルかパッケージの単位で扱うことが普通です。ここからはファイル全体を構文解析する方法を見ていきます。

== ファイルの構造

まず、Goのソースコードファイルの構造を確認しておきましょう。

TBD spec

== parser.ParseFile

Goのソースコードファイルの構文解析を行うには `parser.ParseFile` を使用します。

godoc::go/parser.ParseFile[]

第二引数の `filename` と第三引数の `src` はふたつで一組になっていて、構文解析するソースコードを指定します。`src != nil` であるときは `filename` に指定されたファイルを読み込み、それ以外の場合は `src` をソースコードとして読み込み、`filename` はソースコードの位置情報にだけ使われます。`src` に指定できるのは `string` か `[]byte` か `io.Reader` のいずれかのみです。

第一引数の `fset` は構文解析によって得られた構文木のノードの詳細な位置情報を保持する `token.FileSet` 構造体へのポインタです。詳しくは <<ソースコード中の位置>> で説明しますが、基本的に、`token.NewFileSet()` で得られるものを渡せば十分です。

最後の引数 `mode` では構文解析する範囲の指定などが行えます。後で <<コメントとドキュメント>> を扱うときに少し触れます。

goexample::parsefile[]
goexample::parsefile[output]

例では `src` 変数のもつソースコードを構文解析し、トップレベルの宣言を印字します。今回は `import` 宣言が `*ast.GenDecl` として、関数 `func f` が `*ast.FuncDecl` として得られました。

== ast.File

ファイルは `ast.File` 構造体で表現され、パッケージ名やトップレベルの宣言の情報を含んでいます。

godoc::go/ast.File[]

他にもいろいろなフィールドがありますが、

* `Package` は <<ソースコード中の位置>>、
* `Scope` と `Unresolved` は <<スコープ>>、
* `Doc` と `Comments` は <<コメントとドキュメント>>

で解説します。

// Imports は Decls のうち IMPORT なものをフラットに並べてるだけで parser.ImportsOnly なときに便利ってくらい？
// 5be77a204bee72c81a8f0182d0a23bfd32b36ab9

== ast.Decl

`ast.Decl` インターフェースはGoソースコードにおける宣言（declaration）に対応する構文木のノードです。<<ast.Expr>> と同様に公開されたメソッドの定義されていない、分類用のインターフェースです。Goの宣言には

* パッケージのインポート（`import`）
* 変数および定数（`var`、`const`）
* 型（`type`）
* 関数およびメソッド（`func`）

といったものがありますが、`ast.Decl` インターフェースを実装している構造体は `*ast.GenDecl` と `*ast.FuncDecl` の2つのみです。後者は関数及びメソッドの宣言に相当し、前者が残りすべてをカバーします。

== ast.FuncDecl

godoc::go/ast.FuncDecl[]

== ast.GenDecl

godoc::go/ast.GenDecl[]

Specs 複数
